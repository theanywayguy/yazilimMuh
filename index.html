<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Yazılım Muhendisligi Quiz</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
      .correct {
        color: #10b981;
      }
      .incorrect {
        color: #ef4444;
      }
      .popup {
        display: none;
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background: white;
        padding: 2rem;
        border-radius: 0.5rem;
        box-shadow: 0 10px 15px rgba(0, 0, 0, 0.2);
        z-index: 50;
      }
      .overlay {
        display: none;
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.5);
        z-index: 40;
      }
    </style>
  </head>
  <body class="bg-gray-100 font-sans">
    <div class="max-w-4xl mx-auto p-6">
      <h1 class="text-3xl font-bold text-center text-gray-800 mb-6">
        Yazilim Muhendisligi Quiz
      </h1>
      <div class="bg-white p-6 rounded-lg shadow-lg">
        <div class="flex justify-center mb-4">
          <label for="modelSelect" class="mr-2 text-lg text-gray-700"
            >Select Quiz Model:</label
          >
          <select id="modelSelect" class="p-2 border rounded-lg">
            <option value="model1">PDF 1</option>
            <option value="model2">PDF 2</option>
            <option value="model3">PDF 3</option>
            <option value="model4">PDF 4</option>
            <option value="model5">PDF 5</option>
            <option value="model6">PDF 6</option>
            <option value="model7">LEAKED</option>
          </select>
        </div>
        <div id="score" class="text-lg text-gray-700 mb-4">Score: 0/50</div>
        <div id="questionArea" class="mb-6"></div>
        <div id="explanation" class="p-4 border rounded-lg hidden"></div>
        <div class="flex justify-center space-x-4 mt-4">
          <button
            id="submitBtn"
            class="bg-blue-600 text-white px-6 py-2 rounded-lg hover:bg-blue-700 transition"
          >
            Submit Answer
          </button>
          <button
            id="resetBtn"
            class="bg-red-600 text-white px-6 py-2 rounded-lg hover:bg-red-700 transition"
          >
            Reset Quiz
          </button>
          <button
            id="randomBtn"
            class="bg-green-600 text-white px-6 py-2 rounded-lg hover:bg-green-700 transition"
          >
            Randomize Questions
          </button>
        </div>
        <table class="w-full mt-6 border-collapse">
          <thead>
            <tr class="bg-green-600 text-white">
              <th class="border p-2">Question #</th>
              <th class="border p-2">Status</th>
            </tr>
          </thead>
          <tbody id="tableBody" class="text-gray-700"></tbody>
        </table>
      </div>
    </div>
    <div id="overlay" class="overlay"></div>
    <div id="popup" class="popup">
      <h2 class="text-2xl font-bold text-gray-800 mb-4">Quiz Completed!</h2>
      <p id="popupScore" class="text-lg mb-4"></p>
      <button
        id="retryWrongBtn"
        class="bg-blue-600 text-white px-4 py-2 rounded-lg hover:bg-blue-700 transition"
      >
        Retry Wrong Questions
      </button>
      <button
        id="closePopupBtn"
        class="bg-gray-600 text-white px-4 py-2 rounded-lg hover:bg-gray-700 transition ml-2"
      >
        Close
      </button>
    </div>

    <script>
      const questionsModel1 = [
        {
          question: "Yazılım nedir?",
          options: [
            "A) Donanım bileşenlerinin fiziksel birleşimi",
            "B) Tanımlanmış bir işlevi yerine getiren bir ürün",
            "C) Yalnızca algoritmalardan oluşan bir yapı",
            "D) Bilgisayar donanımını üreten bir sistem",
            "E) Kullanıcı arayüzü tasarımı",
          ],
          correct: 1,
          explanation:
            "Yazılım, tanımlanmış bir işlevi yerine getiren, girdi ve çıktıları olan bir ürün olarak tanımlanmıştır.",
        },
        {
          question: "Yazılımın temel amacı nedir?",
          options: [
            "A) Donanımı kontrol etmek",
            "B) Veriyi bilgiye dönüştürmek",
            "C) Algoritma tasarlamak",
            "D) Kullanıcı arayüzü oluşturmak",
            "E) Sistem güvenliğini sağlamak",
          ],
          correct: 1,
          explanation:
            "Yazılımın temel amacının 'veri'yi 'bilgi'ye dönüştürmek olduğu belirtilmiştir.",
        },
        {
          question: "Yazılım geliştirme sürecinde hangi aşama yer almaz?",
          options: [
            "A) Gereksinim Aşaması",
            "B) Tasarım Aşaması",
            "C) Donanım Üretim Aşaması",
            "D) Gerçekleştirim Aşaması",
            "E) Bakım Aşaması",
          ],
          correct: 2,
          explanation:
            "Yazılım geliştirme süreci, gereksinim, tasarım, gerçekleştirim ve bakım gibi aşamaları içerir; donanım üretimi bu sürece dahil değildir.",
        },
        {
          question:
            "Yazılım uygulamalarından hangisi gömülü sistemlerle ilişkilidir?",
          options: [
            "A) Web-based software",
            "B) Embedded software",
            "C) Business software",
            "D) Personal computer software",
            "E) Artificial intelligence software",
          ],
          correct: 1,
          explanation:
            "Gömülü sistemlerle ilişkilendirilen yazılım türü 'Embedded software'dir.",
        },
        {
          question: "Yazılım problemlerinden biri nedir?",
          options: [
            "A) Donanım uyumluluğu",
            "B) Düşük kalite",
            "C) Hızlı geliştirme",
            "D) Düşük maliyet",
            "E) Yüksek kullanıcı memnuniyeti",
          ],
          correct: 1,
          explanation:
            "Yazılım problemleri arasında 'Düşük Kalite' açıkça listelenmiştir.",
        },
        {
          question: "Yazılımda mantık (algoritma) neden önemlidir?",
          options: [
            "A) Donanımı kontrol eder",
            "B) İşin mantığını yazılıma yansıtır",
            "C) Veriyi depolar",
            "D) Kullanıcı arayüzünü tasarlar",
            "E) Belgeleri düzenler",
          ],
          correct: 1,
          explanation:
            "Mantık (algoritma), bilgisayarlaştırılmak istenen işin mantığını yazılıma yansıtmak için en önemli bileşenlerden biridir.",
        },
        {
          question: "Yazılım üretiminde belgelerin rolü nedir?",
          options: [
            "A) Kod yazımını hızlandırır",
            "B) Ara üretimlere ait bilgileri düzenler",
            "C) Donanımı test eder",
            "D) Kullanıcı arayüzünü geliştirir",
            "E) Veriyi analiz eder",
          ],
          correct: 1,
          explanation:
            "Belgeler, yazılım üretiminde planlama, analiz ve tasarım gibi aşamalardaki bilgileri düzenlemek için gereklidir.",
        },
        {
          question: "Günümüzde yazılım geliştirme nasıl gerçekleştirilir?",
          options: [
            "A) Tek kişi tarafından",
            "B) Bir takım tarafından",
            "C) Yalnızca otomasyonla",
            "D) Donanım mühendisleriyle",
            "E) Kullanıcılar tarafından",
          ],
          correct: 1,
          explanation:
            "Günümüzde yazılım geliştirme bir takım çalışmasıyla gerçekleştirilmektedir.",
        },
        {
          question: "Programın bakım çalışmalarının bir nedeni nedir?",
          options: [
            "A) Her olasılığın test edilememesi",
            "B) Donanımın eskimesi",
            "C) Kullanıcı arayüzünün değişmesi",
            "D) Verinin silinmesi",
            "E) Algoritmanın bozulması",
          ],
          correct: 0,
          explanation:
            "Hiçbir program tüm olasılıklar göz önüne alınarak test edilemez, bu nedenle bakım çalışmaları gereklidir.",
        },
        {
          question: "Yazılım ve donanım arasındaki temel fark nedir?",
          options: [
            "A) Yazılım üretilir, donanım geliştirilir",
            "B) Yazılım geliştirilir, donanım üretilir",
            "C) Yazılım fizikseldir, donanım soyuttur",
            "D) Yazılım eskimez, donanım eskimez",
            "E) Yazılım kopyalanamaz, donanım kopyalanır",
          ],
          correct: 1,
          explanation:
            "Yazılım geliştirilirken, donanım fabrika ortamında seri üretimle üretilir.",
        },
        {
          question: "Yazılımın eskimesi ne anlama gelir?",
          options: [
            "A) Donanımın bozulması",
            "B) Yeni ihtiyaçları karşılayamaması",
            "C) Kodun silinmesi",
            "D) Verinin kaybolması",
            "E) Algoritmanın değişmesi",
          ],
          correct: 1,
          explanation:
            "Yazılımın eskimesi, yeni ihtiyaçları karşılayamaması veya kullandığı teknolojinin eskimesi olarak tanımlanır.",
        },
        {
          question:
            "Yazılımın donanım kadar önemli olmasının bir örneği nedir?",
          options: [
            "A) Web sitelerinin hızlı yüklenmesi",
            "B) Diyaliz makinelerinin yazılım uyumsuzluğu",
            "C) Donanımın seri üretimi",
            "D) Algoritmaların optimize edilmesi",
            "E) Verilerin depolanması",
          ],
          correct: 1,
          explanation:
            "Diyaliz makinelerinin 2000 yılı uyumsuzluğu nedeniyle çalışamaması, yazılımın önemini gösteren bir örnektir.",
        },
        {
          question:
            "Yazılım kopyalama ile donanım kopyalama arasındaki fark nedir?",
          options: [
            "A) Yazılım kopyalamak hataları çözer",
            "B) Donanım kopyalamak maliyeti artırır",
            "C) Yazılım kopyalamak hatalara çözüm değildir",
            "D) Donanım kopyalamak gereksizdir",
            "E) Yazılım kopyalamak donanımı etkiler",
          ],
          correct: 2,
          explanation:
            "Yazılımı kopyalamak hatalara çözüm olmaz, ancak donanımda kopya hata toleransı için kullanılabilir.",
        },
        {
          question: "Yazılımda kalite özelliklerinden biri hangisidir?",
          options: [
            "A) Hız",
            "B) Güvenirlik",
            "C) Renk",
            "D) Boyut",
            "E) Ağırlık",
          ],
          correct: 1,
          explanation:
            "Yazılımda kalite özellikleri arasında 'Güvenirlik' yer alır.",
        },
        {
          question:
            "UML’de hangi diyagram türü yapısal diyagramlar arasında yer alır?",
          options: [
            "A) State Machine Diagram",
            "B) Class Diagram",
            "C) Use Case Diagram",
            "D) Activity Diagram",
            "E) Timing Diagram",
          ],
          correct: 1,
          explanation:
            "Class Diagram, UML’de yapısal diyagramlar arasında yer alır.",
        },
        {
          question:
            "Yazılım geliştirme sürecinde bakım aşamasında hangi tür bakım yer alır?",
          options: [
            "A) Corrective",
            "B) Hardware",
            "C) Network",
            "D) Security",
            "E) Design",
          ],
          correct: 0,
          explanation:
            "Bakım aşamasında 'Corrective' (düzeltici) bakım türü yer alır.",
        },
        {
          question: "Yazılım geçmişinde genel bir sorun nedir?",
          options: [
            "A) Geliştirme maliyetlerinin düşük olması",
            "B) Teslimattan önce tüm hataların bulunamaması",
            "C) Hızlı teslimat",
            "D) Kullanıcı taleplerinin fazlasıyla karşılanması",
            "E) Gelişimin kolayca ölçülmesi",
          ],
          correct: 1,
          explanation:
            "Geçmişte yazılımda sıkça sorulan bir soru, teslimattan önce tüm hataların neden bulunamadığıdır.",
        },
        {
          question: "Sistem nedir?",
          options: [
            "A) Yalnızca donanımdan oluşan bir yapı",
            "B) Birbiryle alakalı programlardan oluşan bir koleksiyon",
            "C) Tek bir program",
            "D) Kullanıcı arayüzü",
            "E) Veri tabanı",
          ],
          correct: 1,
          explanation:
            "Sistem, birbiryle alakalı programlardan oluşan bir koleksiyon olarak tanımlanmıştır.",
        },
        {
          question: "Yazılımın bileşenlerinden biri hangisidir?",
          options: [
            "A) Donanım",
            "B) Mantık (algoritma)",
            "C) Fiziksel bileşenler",
            "D) Elektrik devreleri",
            "E) Ağ ekipmanları",
          ],
          correct: 1,
          explanation:
            "Yazılımın bileşenleri arasında 'Mantık (algoritma)' yer alır.",
        },
        {
          question: "Yazılım üretiminde hangi disiplin gereklidir?",
          options: [
            "A) Elektrik mühendisliği",
            "B) Mühendislik disiplini",
            "C) Kimya mühendisliği",
            "D) Mekanik mühendisliği",
            "E) Matematik disiplini",
          ],
          correct: 1,
          explanation: "Yazılım üretimi bir mühendislik disiplini gerektirir.",
        },
        {
          question: "Yazılım geliştirme maliyetleri neden yüksektir?",
          options: [
            "A) Hızlı teslimat nedeniyle",
            "B) Donanım maliyetleri nedeniyle",
            "C) Geçmişte sıkça sorulan bir sorun olarak",
            "D) Kullanıcı taleplerinin az olması nedeniyle",
            "E) Düşük kalite nedeniyle",
          ],
          correct: 2,
          explanation:
            "Geliştirme maliyetlerinin neden yüksek olduğu, yazılım geçmişinde genel bir sorun olarak belirtilmiştir.",
        },
        {
          question: "Yazılımın veri bileşeni ne yapar?",
          options: [
            "A) Donanımı kontrol eder",
            "B) Veriyi bilgiye dönüştürür",
            "C) Algoritmayı tasarlar",
            "D) Kullanıcı arayüzünü oluşturur",
            "E) Belgeleri düzenler",
          ],
          correct: 1,
          explanation:
            "Veri bileşeni, yazılımın temel amacı olan veriyi bilgiye dönüştürme sürecinde rol oynar.",
        },
        {
          question: "Yazılımın insan bileşeni kimleri içerir?",
          options: [
            "A) Yalnızca geliştiriciler",
            "B) Kullanıcılar ve geliştiriciler",
            "C) Yalnızca kullanıcılar",
            "D) Donanım mühendisleri",
            "E) Sistem yöneticileri",
          ],
          correct: 1,
          explanation:
            "Yazılımın insan bileşeni, hem kullanıcıları hem de geliştiricileri içerir.",
        },
        {
          question: "Yazılımın ana çıktısı nedir?",
          options: [
            "A) Donanım",
            "B) Program (kod)",
            "C) Veri tabanı",
            "D) Kullanıcı arayüzü",
            "E) Belgeler",
          ],
          correct: 1,
          explanation:
            "Yazılımın ana çıktısı sonuçta bir bilgisayar programıdır.",
        },
        {
          question: "Yazılımda yeniden kullanılabilirlik oranı nedir?",
          options: [
            "A) %50-60",
            "B) %1-2",
            "C) %80-90",
            "D) %30-40",
            "E) %10-20",
          ],
          correct: 1,
          explanation:
            "Günümüzde yeniden kullanılabilir yazılım oranı %1-2 olarak belirtilmiştir.",
        },
      ];
      questionsModel2 = [
        {
          question: "Gereksinim yakalama ve analizi süreci neyi kapsar?",
          options: [
            "A) Donanım tasarımını",
            "B) Sistem hizmetlerinin ve kısıtlamalarının oluşturulmasını",
            "C) Yazılım kodlamasını",
            "D) Kullanıcı arayüzü tasarımını",
            "E) Veri tabanı yönetimini",
          ],
          correct: 1,
          explanation:
            "Gereksinim yakalama ve analizi, sistemin sağlaması gereken hizmetlerin ve çalışması gereken kısıtlamaların oluşturulmasını içerir.",
        },
        {
          question: "Gereksinimlerin türetilmesi adımlarından biri hangisidir?",
          options: [
            "A) Kod yazımı",
            "B) Fizibilite çalışması",
            "C) Donanım testi",
            "D) Kullanıcı eğitimi",
            "E) Sistem bakımı",
          ],
          correct: 1,
          explanation:
            "Gereksinimlerin türetilmesi adımları arasında 'Fizibilite Çalışması' yer alır.",
        },
        {
          question: "Gereksinim analizinde hangi faaliyet gerçekleştirilir?",
          options: [
            "A) Donanım seçimi",
            "B) Gereksinimlerin önceliklendirilmesi",
            "C) Kod optimizasyonu",
            "D) Veri tabanı tasarımı",
            "E) Kullanıcı arayüzü testi",
          ],
          correct: 1,
          explanation:
            "Gereksinim analizi, ihtiyaçların belirlenmesi ve önceliklendirilmesi gibi faaliyetleri içerir.",
        },
        {
          question: "Information Domain hangi görüşleri içerir?",
          options: [
            "A) Bilgi İçeriği, Bilgi Akışı, Bilgi Yapısı",
            "B) Kod Yapısı, Veri Tabanı, Kullanıcı Arayüzü",
            "C) Donanım Gereksinimleri, Yazılım Testleri, Sistem Bakımı",
            "D) Algoritma Tasarımı, Veri Depolama, Güvenlik",
            "E) Proje Yönetimi, Risk Analizi, Kalite Kontrol",
          ],
          correct: 0,
          explanation:
            "Information Domain, Bilgi İçeriği, Bilgi Akışı ve Bilgi Yapısı olmak üzere üç görüş içerir.",
        },
        {
          question: "Gereksinimleri ortaya çıkarma yöntemlerinden biri nedir?",
          options: [
            "A) Kod incelemesi",
            "B) Röportajlar (Interviews)",
            "C) Donanım testi",
            "D) Veri tabanı optimizasyonu",
            "E) Sistem bakımı",
          ],
          correct: 1,
          explanation:
            "Gereksinimleri ortaya çıkarma yöntemleri arasında 'Röportajlar' (Interviews) yer alır.",
        },
        {
          question: "İyi bir röportaj için ne önerilir?",
          options: [
            "A) Daha önce söylenen istekleri unutmamak",
            "B) Uygulama alanına aşina olmak",
            "C) Teknik terimler kullanmaktan kaçınmak",
            "D) Görüşme raporunu paylaşmamak",
            "E) Rastgele sorular sormak",
          ],
          correct: 1,
          explanation:
            "İyi bir röportaj için uygulama alanına aşina olmak önerilir.",
        },
        {
          question: "Senaryolar neden faydalıdır?",
          options: [
            "A) Donanımı test eder",
            "B) Ürünün davranışını gösterebilir",
            "C) Kod yazımını hızlandırır",
            "D) Veri tabanını optimize eder",
            "E) Kullanıcı arayüzünü tasarlar",
          ],
          correct: 1,
          explanation:
            "Senaryolar, ürünün davranışını gösterebildiği ve kullanıcılar tarafından anlaşılabildiği için faydalıdır.",
        },
        {
          question: "Gereksinimlerin tanımlanması hangi özelliği taşır?",
          options: [
            "A) Teknik bir dilde yazılır",
            "B) Doğal bir dilde ve anlaşılabilir olmalıdır",
            "C) Yalnızca geliştiriciler için hazırlanır",
            "D) Matematiksel formüller içerir",
            "E) Donanım gereksinimlerini listeler",
          ],
          correct: 1,
          explanation:
            "Gereksinimlerin tanımlanması, doğal bir dilde yazılır ve müşteri, kullanıcılar ve tedarikçiler tarafından anlaşılabilir olmalıdır.",
        },
        {
          question: "Fonksiyonel gereksinimler neyi ifade eder?",
          options: [
            "A) Yazılımın güvenilirliğini",
            "B) Hedef yazılımın işlevselliğini",
            "C) Sistem donanımını",
            "D) Kullanıcı arayüzünü",
            "E) Bakım süreçlerini",
          ],
          correct: 1,
          explanation:
            "Fonksiyonel gereksinimler, hedef yazılımın işlevselliğini ifade eder.",
        },
        {
          question: "Fonksiyonel olmayan gereksinimler hangi örneği içerir?",
          options: [
            "A) Sistemin bir dosyayı kaydetmesi",
            "B) Sistemin güvenilirliği",
            "C) Kullanıcı giriş ekranı tasarımı",
            "D) Veri tabanı sorgusu",
            "E) Kod optimizasyonu",
          ],
          correct: 1,
          explanation:
            "Fonksiyonel olmayan gereksinimler, güvenilirlik gibi yazılımın özelliklerini kapsar.",
        },
        {
          question: "Gereksinim dokümanı hangi kuralı karşılamalıdır?",
          options: [
            "A) Yalnızca iç davranışı belirtir",
            "B) Değiştirilmesi kolay olmalıdır",
            "C) Teknik terimler içermemelidir",
            "D) Donanım gereksinimlerini listeler",
            "E) Matematiksel analiz gerektirir",
          ],
          correct: 1,
          explanation:
            "Gereksinim dokümanı, Heninger’in 1980 kurallarına göre değiştirilmesi kolay olmalıdır.",
        },
        {
          question: "Gereksinim şartnamesi kimler arasında bir sözleşmedir?",
          options: [
            "A) Kullanıcılar ve donanım tedarikçileri",
            "B) Sistem tedarikçisi ve yazılım geliştirici",
            "C) Geliştiriciler ve test ekibi",
            "D) Müşteriler ve bakım ekibi",
            "E) Kullanıcılar ve yöneticiler",
          ],
          correct: 1,
          explanation:
            "Gereksinim şartnamesi, sistem tedarikçisi ile yazılım geliştirici arasındaki bir sözleşmedir.",
        },
        {
          question: "Gereksinim şartnamesinde hangi bölüm yer alır?",
          options: [
            "A) Donanım tasarımı",
            "B) Bilgi açıklaması",
            "C) Kod örnekleri",
            "D) Kullanıcı arayüzü taslağı",
            "E) Test sonuçları",
          ],
          correct: 1,
          explanation:
            "Gereksinim şartnamesi, bilgi içeriği, akışı ve yapısını içeren 'Bilgi açıklaması' bölümünü içerir.",
        },
        {
          question: "Resmi şartname kullanmanın bir avantajı nedir?",
          options: [
            "A) Hatalı talepleri azaltır",
            "B) Daha az teknik bilgi gerektirir",
            "C) Kullanıcılar tarafından kolayca yazılır",
            "D) Donanım gereksinimlerini tanımlar",
            "E) Kod yazımını hızlandırır",
          ],
          correct: 0,
          explanation:
            "Resmi şartname, hatalı talepleri azaltma avantajına sahiptir.",
        },
        {
          question: "Modelleme hangi yeteneğe sahiptir?",
          options: [
            "A) Donanımı test etme",
            "B) Bilginin dönüşümünü ve sistem davranışını temsil etme",
            "C) Kod yazma",
            "D) Kullanıcı arayüzü tasarlama",
            "E) Veri tabanı oluşturma",
          ],
          correct: 1,
          explanation:
            "Modelleme, bilginin dönüşümünü, fonksiyonları ve sistem davranışını temsil etme yeteneğine sahiptir.",
        },
        {
          question: "Şartname notasyonu neden özel bir notasyon gerektirir?",
          options: [
            "A) Doğal dil aşırı esnektir",
            "B) Kod yazımını kolaylaştırır",
            "C) Donanım gereksinimlerini tanımlar",
            "D) Kullanıcı arayüzünü düzenler",
            "E) Veri tabanı yapısını oluşturur",
          ],
          correct: 0,
          explanation:
            "Doğal dilin aşırı esnek olması nedeniyle şartname notasyonu özel bir notasyon gerektirir.",
        },
        {
          question: "Fonksiyonel olmayan gereksinimlere bir örnek nedir?",
          options: [
            "A) Sistemin bir dosyayı kaydetmesi",
            "B) Sistemin kullanımı kolay olması",
            "C) Kullanıcı giriş ekranı tasarımı",
            "D) Veri tabanı sorgusu",
            "E) Kod optimizasyonu",
          ],
          correct: 1,
          explanation:
            "Fonksiyonel olmayan gereksinimler, sistemin kullanımı kolay olması gibi özellikleri içerir.",
        },
        {
          question: "Gereksinimlerin doğrulanmasında hangi adım yer alır?",
          options: [
            "A) Kod yazımı",
            "B) Gereksinimlerin eksiksiz olduğunun gösterilmesi",
            "C) Donanım testi",
            "D) Kullanıcı arayüzü tasarımı",
            "E) Veri tabanı optimizasyonu",
          ],
          correct: 1,
          explanation:
            "Gereksinimlerin doğrulanması, gereksinimlerin eksiksiz olduğunu gösterme adımını içerir.",
        },
        {
          question: "Yapısal sistem analizinde ilk adım nedir?",
          options: [
            "A) Donanım gereksinimlerini belirlemek",
            "B) Veri akış şemasını çizmek",
            "C) Kod yazmak",
            "D) Kullanıcı arayüzünü tasarlamak",
            "E) Veri tabanını optimize etmek",
          ],
          correct: 1,
          explanation:
            "Yapısal sistem analizinde ilk adım 'Veri Akış Şemasını Çizmek'tir.",
        },
        {
          question:
            "Gereksinimleri ortaya çıkarmada anlamlı sorular sormak neden önemlidir?",
          options: [
            "A) Donanımı test eder",
            "B) Müşterinin ihtiyaçlarını keşfetmeye yardımcı olur",
            "C) Kod yazımını hızlandırır",
            "D) Veri tabanını optimize eder",
            "E) Kullanıcı arayüzünü tasarlar",
          ],
          correct: 1,
          explanation:
            "Anlamlı sorular sormak, müşterinin ihtiyaçlarını keşfetmek için önemlidir.",
        },
        {
          question: "Çalışma prensiplerinden biri nedir?",
          options: [
            "A) Donanım gereksinimlerini tanımlamak",
            "B) Yazılımın işlevlerini tanımlamak",
            "C) Kod yazımını tamamlamak",
            "D) Kullanıcı arayüzünü tasarlamak",
            "E) Veri tabanını oluşturmak",
          ],
          correct: 1,
          explanation:
            "Çalışma prensipleri, yazılımın gerçekleştireceği işlevlerin tanımlanmasını içerir.",
        },
        {
          question: "Gereksinim şartnamesinde hangi kriter yer alır?",
          options: [
            "A) Kod örnekleri",
            "B) Doğrulama kriterleri",
            "C) Donanım tasarımı",
            "D) Kullanıcı arayüzü taslağı",
            "E) Test sonuçları",
          ],
          correct: 1,
          explanation:
            "Gereksinim şartnamesi, başarılı uygulama için doğrulama kriterlerini içerir.",
        },
        {
          question: "Senaryolar nasıl tasvir edilebilir?",
          options: [
            "A) Donanım bileşenlerini listeleyerek",
            "B) Eylemleri listeleyerek veya olayların sırasını çizerek",
            "C) Kod yazarak",
            "D) Veri tabanı tasarlayarak",
            "E) Kullanıcı arayüzü oluşturarak",
          ],
          correct: 1,
          explanation:
            "Senaryolar, eylemleri listeleyerek veya olayların sırasını çizerek tasvir edilebilir.",
        },
        {
          question: "Bazı problemlerden biri nedir?",
          options: [
            "A) Kullanıcılar arasındaki çakışan istekler",
            "B) Hızlı geliştirme",
            "C) Düşük maliyet",
            "D) Yüksek kullanıcı memnuniyeti",
            "E) Eksiksiz gereksinimler",
          ],
          correct: 0,
          explanation:
            "Bazı problemler arasında kullanıcılar arasındaki çakışan istekler yer alır.",
        },
        {
          question:
            "Gereksinimlerin tanımlanması kimler tarafından anlaşılabilir olmalıdır?",
          options: [
            "A) Yalnızca geliştiriciler",
            "B) Müşteri, kullanıcılar ve tedarikçiler",
            "C) Yalnızca müşteriler",
            "D) Donanım mühendisleri",
            "E) Test ekibi",
          ],
          correct: 1,
          explanation:
            "Gereksinimlerin tanımlanması, müşteri, kullanıcılar ve tedarikçiler tarafından anlaşılabilir olmalıdır.",
        },
        {
          question: "Resmi şartname hangi örneği içerir?",
          options: [
            "A) Donanım gereksinimleri",
            "B) Önkoşullu ve sonkoşullu fonksiyonlar",
            "C) Kullanıcı arayüzü tasarımları",
            "D) Veri tabanı yapıları",
            "E) Test senaryoları",
          ],
          correct: 1,
          explanation:
            "Resmi şartname, önkoşullu ve sonkoşullu fonksiyonlar gibi örnekleri içerir.",
        },
        {
          question: "Modelleme türlerinden biri hangisidir?",
          options: [
            "A) Donanım modelleri",
            "B) Veri modelleri",
            "C) Kod modelleri",
            "D) Kullanıcı arayüzü modelleri",
            "E) Test modelleri",
          ],
          correct: 1,
          explanation: "Modelleme türleri arasında 'Veri modelleri' yer alır.",
        },
        {
          question: "Şartname dokümanı hangi kısıtlamayı içerebilir?",
          options: [
            "A) Kod yazım süresi",
            "B) Son tarih",
            "C) Donanım maliyeti",
            "D) Kullanıcı arayüzü rengi",
            "E) Veri tabanı boyutu",
          ],
          correct: 1,
          explanation:
            "Şartname dokümanı, son tarih gibi kısıtlamaları içerebilir.",
        },
        {
          question: "Gereksinimleri ortaya çıkarmada hangi yöntem kullanılmaz?",
          options: [
            "A) Röportajlar",
            "B) Senaryolar",
            "C) Kullanıcı anketleri",
            "D) Kod yazımı",
            "E) Video kameralar",
          ],
          correct: 3,
          explanation:
            "Gereksinimleri ortaya çıkarmada kod yazımı bir yöntem olarak kullanılmaz.",
        },
        {
          question: "Yapısal sistem analizinde hangi adım sonlarda yer alır?",
          options: [
            "A) Veri akış şemasını çizmek",
            "B) Donanım gereksinimlerini belirlemek",
            "C) Bilgisayarlaştırılacak bölümlere karar vermek",
            "D) Veri akışlarının detaylarını belirlemek",
            "E) Süreçlerin mantığını tanımlamak",
          ],
          correct: 1,
          explanation:
            "Yapısal sistem analizinde 'Donanım gereksinimlerinin belirlenmesi' son adımlardan biridir.",
        },
      ];
      const questionsModel3 = [
        {
          question: "Yazılım mühendisliğinde tasarım nedir?",
          options: [
            "A) Kod yazma sürecidir",
            "B) Mantıksal modelin fiziksel modele dönüştürülmesi çalışmasıdır",
            "C) Donanım bileşenlerinin seçilmesi işlemidir",
            "D) Kullanıcı arayüzünün test edilmesi sürecidir",
            "E) Veri tabanının optimize edilmesi çalışmasıdır",
          ],
          correct: 1,
          explanation:
            "Tasarım, sistem analizi sonucunda üretilen mantıksal modelin fiziksel modele dönüştürülmesi çalışmasıdır.",
        },
        {
          question: "Fiziksel model hangi unsuru içerir?",
          options: [
            "A) Kullanıcı gereksinimlerini",
            "B) Yazılımın hangi parçalardan oluşacağını",
            "C) Donanım test sonuçlarını",
            "D) Kod optimizasyon yöntemlerini",
            "E) Veri tabanı şifreleme tekniklerini",
          ],
          correct: 1,
          explanation:
            "Fiziksel model, yazılımın hangi parçalardan oluşacağını ve bu parçalar arasındaki ilişkileri içerir.",
        },
        {
          question: "Tasarımın önemi hangi faktörü doğrudan etkiler?",
          options: [
            "A) Donanım maliyetini",
            "B) Sistemin kararlılığını",
            "C) Veri tabanı boyutunu",
            "D) Kullanıcı sayısını",
            "E) Kod uzunluğunu",
          ],
          correct: 1,
          explanation:
            "Tasarım, sistemin kararlılığı gibi projeyi doğrudan etkileyen faktörleri belirler.",
        },
        {
          question: "Tasarım kavramlarından 'soyutlama' neyi sağlar?",
          options: [
            "A) Detayları gizleyerek yukarıdan bakabilme imkanı",
            "B) Modüllerin iç yapısını tanımlar",
            "C) Veri tabanı tasarımını kolaylaştırır",
            "D) Kullanıcı arayüzünü optimize eder",
            "E) Kod yazımını hızlandırır",
          ],
          correct: 0,
          explanation:
            "Soyutlama, detayları gizleyerek tasarıma yukarıdan bakabilme imkanı sağlar.",
        },
        {
          question: "Modülerlik neyi ifade eder?",
          options: [
            "A) Sistemi tek bir modüle toplama",
            "B) Sistemi istenen kalite faktörleri ışığında parçalara ayırma",
            "C) Donanım bileşenlerini birleştirme",
            "D) Kullanıcı arayüzünü tasarlama",
            "E) Veri tabanını optimize etme",
          ],
          correct: 1,
          explanation:
            "Modülerlik, sistemi istenen kalite faktörleri ışığında parçalara ayırma sonucudur.",
        },
        {
          question:
            "Tasarım aşamalarından 'senaryo tabanlı elemanlar' hangi diyagramı içerir?",
          options: [
            "A) Sınıf diyagramı",
            "B) Kullanım-durumu diyagramı",
            "C) Veri akış diyagramı",
            "D) Durum diyagramı",
            "E) İşbirliği diyagramı",
          ],
          correct: 1,
          explanation:
            "Senaryo tabanlı elemanlar, kullanım-durumu diyagramını içerir.",
        },
        {
          question: "İşlevsel bağımsızlık ne anlama gelir?",
          options: [
            "A) Modüllerin birbirine bağlı olması",
            "B) Modüllerin parametre ile veri alıp sadece sonuç döndürmesi",
            "C) Modüllerin iç yapısının gizlenmesi",
            "D) Donanım ile yazılımın entegrasyonu",
            "E) Kullanıcı arayüzünün tasarlanması",
          ],
          correct: 1,
          explanation:
            "İşlevsel bağımsızlık, modüllerin parametre ile veri alıp sadece sonuç döndürmesi anlamına gelir.",
        },
        {
          question: "Veri tasarımı neden ilk yapılması gereken tasarımdır?",
          options: [
            "A) Kullanıcı arayüzünü kolaylaştırır",
            "B) Bilgi saklama ve soyutlama için önemlidir",
            "C) Kod yazımını hızlandırır",
            "D) Donanım gereksinimlerini belirler",
            "E) Sistem testlerini optimize eder",
          ],
          correct: 1,
          explanation:
            "Veri tasarımı, bilgi saklama ve soyutlama açısından önemli olduğu için ilk yapılır.",
        },
        {
          question: "Veri tasarımında çözümleme hangi unsura yöneliktir?",
          options: [
            "A) Veriye erişim yöntemine",
            "B) Kullanıcı arayüzüne",
            "C) Donanım performansına",
            "D) Kod optimizasyonuna",
            "E) Sistem güvenliğine",
          ],
          correct: 0,
          explanation:
            "Veri tasarımında çözümleme, veriye erişim yöntemi gibi unsurlara yöneliktir.",
        },
        {
          question: "Mimari tasarımda alt-sistem nedir?",
          options: [
            "A) Bağımsız çalışabilen bir sistem",
            "B) Kullanıcı arayüzü bileşeni",
            "C) Veri tabanı yapısı",
            "D) Kod optimizasyon aracı",
            "E) Donanım bileşeni",
          ],
          correct: 0,
          explanation:
            "Alt-sistem, diğer alt-sistemlere bağlı olmadan kendi başına çalışabilen bir sistemdir.",
        },
        {
          question: "Modül ile alt-sistem arasındaki fark nedir?",
          options: [
            "A) Modül bağımsız bir sistemdir, alt-sistem değildir",
            "B) Modül diğer modüllere hizmet sağlar, alt-sistem bağımsızdır",
            "C) Modül veri tabanı tasarlar, alt-sistem kod yazar",
            "D) Modül donanımı kontrol eder, alt-sistem veriyi işler",
            "E) Modül kullanıcı arayüzüdür, alt-sistem değildir",
          ],
          correct: 1,
          explanation:
            "Modül, diğer modüllere hizmet sağlar ancak bağımsız bir sistem değildir; alt-sistem ise bağımsız çalışabilir.",
        },
        {
          question: "Yordamsal tasarım neyi tanımlar?",
          options: [
            "A) Kullanıcı arayüzünü",
            "B) Modüllerin iç yapılarındaki algoritmik ayrıntıları",
            "C) Donanım gereksinimlerini",
            "D) Veri tabanı yapısını",
            "E) Sistem testlerini",
          ],
          correct: 1,
          explanation:
            "Yordamsal tasarım, modüllerin iç yapılarındaki algoritmik ayrıntıları tanımlar.",
        },
        {
          question: "Program Tasarım Dili (PDL) nedir?",
          options: [
            "A) Gerçek bir programlama dili",
            "B) Sözde kod (pseudo code) olarak bilinen bir gösterim",
            "C) Donanım tasarım dili",
            "D) Veri tabanı sorgu dili",
            "E) Kullanıcı arayüzü tasarım aracı",
          ],
          correct: 1,
          explanation:
            "Program Tasarım Dili, sözde kod olarak bilinen ve programlama diline benzeyen bir gösterimdir.",
        },
        {
          question:
            "Yordamsal tasarımda grafiksel gösterimlerden biri hangisidir?",
          options: [
            "A) Kod listesi",
            "B) Veri akış diyagramı",
            "C) Donanım şeması",
            "D) Kullanıcı arayüzü taslağı",
            "E) Test raporu",
          ],
          correct: 1,
          explanation:
            "Yordamsal tasarımda grafiksel gösterimlerden biri veri akış diyagramıdır.",
        },
        {
          question: "Kullanıcı arayüzü tasarımında hangi ilke önemlidir?",
          options: [
            "A) Kullanım kolaylığı ve öğrenim zamanı",
            "B) Donanım performansı",
            "C) Kod optimizasyonu",
            "D) Veri tabanı güvenliği",
            "E) Sistem testi",
          ],
          correct: 0,
          explanation:
            "Kullanıcı arayüzü tasarımında kullanım kolaylığı ve öğrenim zamanı esastır.",
        },
        {
          question: "Kullanıcı arayüzünde hangi işlem geri alınabilmelidir?",
          options: [
            "A) Veri tabanı yedekleme",
            "B) Önemli silmeler",
            "C) Donanım testi",
            "D) Kod derleme",
            "E) Sistem güncellemesi",
          ],
          correct: 1,
          explanation:
            "Kullanıcı arayüzünde önemli silmelerin geri alınabilmesi gerektiği belirtilmiştir.",
        },
        {
          question: "Bilgi gösteriminde ne önerilir?",
          options: [
            "A) Veri çokluğu ile kullanıcıyı bunaltmak",
            "B) Grafik ve resimler kullanmak",
            "C) Tutarsız başlık ve renkler kullanmak",
            "D) Hata mesajlarını gizlemek",
            "E) Tüm veriyi listelemek",
          ],
          correct: 1,
          explanation:
            "Bilgi gösteriminde veri çokluğu ile kullanıcıyı bunaltmamak için grafik ve resimler kullanılması önerilir.",
        },
        {
          question: "Kullanıcı arayüzü prototipinde ne amaçlanır?",
          options: [
            "A) Donanım gereksinimlerini belirlemek",
            "B) Kullanıcıdan onay almak",
            "C) Kod yazımını tamamlamak",
            "D) Veri tabanını optimize etmek",
            "E) Sistem testlerini yapmak",
          ],
          correct: 1,
          explanation:
            "Kullanıcı arayüzü prototipi, kullanıcıya gösterilerek onay alınması için hazırlanır.",
        },
        {
          question: "Tasarım kalite ölçütlerinden 'bağlaşım' ne ile ilgilidir?",
          options: [
            "A) Modüllerin iç yapısı",
            "B) Modüller arası ilişki",
            "C) Veri tabanı tasarımı",
            "D) Kullanıcı arayüzü",
            "E) Kod performansı",
          ],
          correct: 1,
          explanation:
            "Bağlaşım, tasarımı oluşturan modüller arası ilişki ile ilgilidir.",
        },
        {
          question: "Yapışıklık (cohesion) neyi ifade eder?",
          options: [
            "A) Modüller arası bağlılığı",
            "B) Modüllerin iç yapısını",
            "C) Donanım performansını",
            "D) Kullanıcı arayüzü tasarımını",
            "E) Veri tabanı yapısını",
          ],
          correct: 1,
          explanation: "Yapışıklık, modüllerin iç yapısı ile ilgilidir.",
        },
        {
          question: "Yüksek kaliteli bir tasarımda bağlaşım nasıl olmalıdır?",
          options: [
            "A) Yüksek olmalıdır",
            "B) Düşük olmalıdır",
            "C) Orta seviyede olmalıdır",
            "D) Sabit olmalıdır",
            "E) Değişken olmalıdır",
          ],
          correct: 1,
          explanation:
            "Yüksek kaliteli bir tasarımda bağlaşım ölçümü az olmalıdır.",
        },
        {
          question: "Yalın veri bağlaşımı neyi tanımlar?",
          options: [
            "A) Modüller arası karmaşık veri paylaşımını",
            "B) Modüllerin tamsayı gibi yalın verilerle iletişimini",
            "C) Modüllerin iç yapısını",
            "D) Donanım ile yazılım entegrasyonunu",
            "E) Kullanıcı arayüzü iletişimini",
          ],
          correct: 1,
          explanation:
            "Yalın veri bağlaşımı, modüllerin tamsayı, karakter gibi yalın verilerle iletişim kurmasını tanımlar.",
        },
        {
          question: "Karmaşık veri bağlaşımı hangi durumda oluşur?",
          options: [
            "A) Modüller yalın verilerle iletişim kurduğunda",
            "B) Modüller karmaşık veri yapılarıyla iletişim kurduğunda",
            "C) Modüller donanım ile iletişim kurduğunda",
            "D) Modüller kullanıcı arayüzü ile iletişim kurduğunda",
            "E) Modüller veri tabanı ile iletişim kurduğunda",
          ],
          correct: 1,
          explanation:
            "Karmaşık veri bağlaşımı, modüllerin kayıt, dizi gibi karmaşık veri yapılarıyla iletişim kurması durumudur.",
        },
        {
          question: "Denetim bağlaşımı nedir?",
          options: [
            "A) Modüllerin ortak veri alanına erişimi",
            "B) Modüllerin denetim verisi ile iletişimi",
            "C) Modüllerin iç yapısının tasarımı",
            "D) Modüllerin kullanıcı arayüzü ile bağlantısı",
            "E) Modüllerin donanım ile entegrasyonu",
          ],
          correct: 1,
          explanation:
            "Denetim bağlaşımı, modüller arasında denetim verisi kullanılarak iletişim kurulmasıdır.",
        },
        {
          question: "Ortak veri bağlaşımı neden istenmez?",
          options: [
            "A) Modülleri bağımsız hale getirir",
            "B) Ortak veri alanını izlemek zordur",
            "C) Kod yazımını hızlandırır",
            "D) Kullanıcı arayüzünü kolaylaştırır",
            "E) Veri tabanını optimize eder",
          ],
          correct: 1,
          explanation:
            "Ortak veri bağlaşımı, ortak veri alanını izlemenin zor olması nedeniyle fazla istenmez.",
        },
        {
          question: "İçerik bağlaşımı nasıl oluşur?",
          options: [
            "A) Modüllerin yalın verilerle iletişim kurmasıyla",
            "B) Bir modülün başka bir modülün veri alanına erişmesiyle",
            "C) Modüllerin donanım ile entegrasyonuyla",
            "D) Modüllerin kullanıcı arayüzü ile bağlantısıyla",
            "E) Modüllerin veri tabanı ile iletişim kurmasıyla",
          ],
          correct: 1,
          explanation:
            "İçerik bağlaşımı, bir modülün başka bir modülün veri alanına erişebilmesiyle oluşur.",
        },
        {
          question: "Yapışıklık ile bağlaşım arasındaki ilişki nedir?",
          options: [
            "A) Doğru orantılıdır",
            "B) Ters orantılıdır",
            "C) Bağımsızdır",
            "D) Eşittir",
            "E) Sabittir",
          ],
          correct: 1,
          explanation:
            "Yapışıklık ile bağlaşım ters orantılıdır; yapışıklık yüksek olduğunda bağlaşım düşük olur.",
        },
        {
          question: "İşlevsel yapışıklık neyi tanımlar?",
          options: [
            "A) Modülün tek bir iş problemine çözüm sunması",
            "B) Modülün birden fazla işlemi bir arada yapması",
            "C) Modülün donanım ile iletişim kurması",
            "D) Modülün kullanıcı arayüzünü tasarlaması",
            "E) Modülün veri tabanını optimize etmesi",
          ],
          correct: 0,
          explanation:
            "İşlevsel yapışıklık, modülün tek bir iş problemine çözüm sunmasıdır.",
        },
        {
          question: "Sırasal yapışıklık hangi durumda oluşur?",
          options: [
            "A) İşlemlerin sırası önemli olmadığında",
            "B) Bir işlemin çıktısı diğerinin girdisi olduğunda",
            "C) İşlemler aynı veriyi kullandığında",
            "D) İşlemler donanım ile iletişim kurduğunda",
            "E) İşlemler kullanıcı arayüzü ile bağlantılı olduğunda",
          ],
          correct: 1,
          explanation:
            "Sırasal yapışıklık, bir işlemin çıktısının diğer bir işlemin girdisi olması durumunda oluşur.",
        },
        {
          question: "İletişimsel yapışıklık neyi ifade eder?",
          options: [
            "A) İşlemlerin aynı girdi veya çıktıyı kullanması",
            "B) İşlemlerin sırasının önemli olması",
            "C) İşlemlerin belirli bir zamanda uygulanması",
            "D) İşlemlerin donanım ile iletişim kurması",
            "E) İşlemlerin kullanıcı arayüzü ile bağlantısı",
          ],
          correct: 0,
          explanation:
            "İletişimsel yapışıklık, modül içindeki işlemlerin aynı girdi veya çıktıyı kullanmasıdır.",
        },
        {
          question: "Yordamsal yapışıklıkta ne önemlidir?",
          options: [
            "A) İşlemlerin veri ilişkisi",
            "B) İşlemlerin sırası",
            "C) İşlemlerin aynı veriyi kullanması",
            "D) İşlemlerin donanım ile bağlantısı",
            "E) İşlemlerin kullanıcı arayüzü ile ilişkisi",
          ],
          correct: 1,
          explanation:
            "Yordamsal yapışıklıkta işlemler arasında veri ilişkisi yoktur, ancak işlem sırası önemlidir.",
        },
        {
          question: "Zamansal yapışıklık hangi durumda oluşur?",
          options: [
            "A) İşlemlerin sırası önemli olduğunda",
            "B) İşlemlerin belirli bir zamanda uygulanması gerektiğinde",
            "C) İşlemlerin aynı veriyi kullandığında",
            "D) İşlemlerin donanım ile iletişim kurduğunda",
            "E) İşlemlerin kullanıcı arayüzü ile bağlantılı olduğunda",
          ],
          correct: 1,
          explanation:
            "Zamansal yapışıklık, işlemlerin belirli bir zamanda uygulanması gerektiğinde ve sırası önemli olmadığında oluşur.",
        },
        {
          question: "Mantıksal yapışıklık neyi tanımlar?",
          options: [
            "A) İşlemlerin rastgele bir araya gelmesi",
            "B) Aynı türdeki işlemlerin bir araya toplanması",
            "C) İşlemlerin sırasının önemli olması",
            "D) İşlemlerin donanım ile iletişim kurması",
            "E) İşlemlerin kullanıcı arayüzü ile bağlantısı",
          ],
          correct: 1,
          explanation:
            "Mantıksal yapışıklık, mantıksal olarak aynı türdeki işlemlerin bir araya toplanmasıdır.",
        },
        {
          question: "Gelişigüzel yapışıklık neyi ifade eder?",
          options: [
            "A) İşlemler arasında ilişki bulunması",
            "B) İşlemler arasında herhangi bir ilişki bulunmaması",
            "C) İşlemlerin sırasının önemli olması",
            "D) İşlemlerin donanım ile iletişim kurması",
            "E) İşlemlerin kullanıcı arayüzü ile bağlantısı",
          ],
          correct: 1,
          explanation:
            "Gelişigüzel yapışıklık, işlemler arasında herhangi bir ilişkinin bulunmaması durumudur.",
        },
        {
          question: "Tasarım dokümantasyonunda hangi unsur yer alır?",
          options: [
            "A) Kod örnekleri",
            "B) Veri tasarımı",
            "C) Donanım test sonuçları",
            "D) Kullanıcı geri bildirimleri",
            "E) Sistem güncelleme planı",
          ],
          correct: 1,
          explanation:
            "Tasarım dokümantasyonu, veri tasarımı gibi unsurları içerir.",
        },
        {
          question: "Tasarım şartnamesi neyi kapsar?",
          options: [
            "A) Donanım gereksinimlerini",
            "B) Tasarım kısıtlamalarını",
            "C) Kod optimizasyon yöntemlerini",
            "D) Kullanıcı arayüzü testlerini",
            "E) Veri tabanı şifreleme tekniklerini",
          ],
          correct: 1,
          explanation:
            "Tasarım şartnamesi, tasarım kısıtlamaları gibi unsurları kapsar.",
        },
        {
          question:
            "Tasarım dokümantasyonunda program arayüzleri hangi türü içerir?",
          options: [
            "A) Yalnızca dahili arayüzler",
            "B) Dış (insan-makine) ve dahili arayüzler",
            "C) Yalnızca donanım arayüzleri",
            "D) Yalnızca veri tabanı arayüzleri",
            "E) Yalnızca kullanıcı arayüzleri",
          ],
          correct: 1,
          explanation:
            "Tasarım dokümantasyonunda program arayüzleri, dış (insan-makine) ve dahili arayüzleri içerir.",
        },
      ];
      const questionsModel4 = [
        {
          question:
            "Belgeye göre yazılım gerçekleştirme aşamasının temel amacı nedir?",
          options: [
            "Yazılımı hata ve kusurlar için test etmek.",
            "Fiziksel modeli bilgisayar ortamında çalışan bir yazılım biçimine dönüştürmek.",
            "Yazılım gereksinimlerini belgelemek.",
            "Donanımı yazılım yürütmesi için optimize etmek.",
            "Yazılım için veritabanı yapısını tasarlamak.",
          ],
          correct: 1,
          explanation:
            "Sayfa 3’te, gerçekleştirme aşamasının fiziksel modeli, süreç ve veri tabanının yapısını içeren bir yazılım biçimine dönüştürme çalışması olduğu belirtiliyor.",
        },
        {
          question:
            "Gerçekleştirme sırasında bir yazılım geliştirme ortamı kullanmanın temel faydası nedir?",
          options: [
            "Otomatik olarak makine kodu üretir.",
            "Belgeleme ihtiyacını ortadan kaldırır.",
            "Bir yazılım geliştirme ortamı oluşturmak için faydalıdır.",
            "Programlama dillerine olan ihtiyacı azaltır.",
            "Donanım uyumluluğunu sağlar.",
          ],
          correct: 2,
          explanation:
            "Sayfa 3’te, ‘Her şeyden önce bir yazılım geliştirme ortamı foolime icin faydalıdır’ denilerek bunun önemi vurgulanıyor.",
        },
        {
          question:
            "Kodlama evresinin kalitesi, nihai yazılım ürününü nasıl etkiler?",
          options: [
            "Donanım gereksinimlerini belirler.",
            "Yalnızca yazılımın hızını etkiler.",
            "Tasarım evresi güçlüyse etkisi olmaz.",
            "Nihai ürünün hem niteliğini hem de bakım özelliğini etkiler.",
            "Yalnızca belgeleme sürecini etkiler.",
          ],
          correct: 3,
          explanation:
            "Sayfa 4’te, kodlama evresinde oluşturulan kaynak kodun son ürünün hem niteliğini hem de bakım özelliğini etkilediği belirtiliyor.",
        },
        {
          question:
            "Belgede programlama dillerinin genel özellikleri arasında hangisi yer almıyor?",
          options: [
            "Tasarımda koda seçim kolaylığı.",
            "Donanım hızı optimizasyonu.",
            "Dilin etkinliği.",
            "Taşınabilirlik.",
            "Tip kontrolü.",
          ],
          correct: 1,
          explanation:
            "Sayfa 5’te genel özellikler arasında tasarımda koda seçim kolaylığı, dilin etkinliği, taşınabilirlik ve tip kontrolü listeleniyor, ancak ‘donanım hızı optimizasyonu’ yer almıyor.",
        },
        {
          question:
            "Yapay zeka uygulamaları için hangi programlama dili özellikle öneriliyor?",
          options: ["C", "Fortran", "Cobol", "Assembly", "Lisp"],
          correct: 4,
          explanation:
            "Sayfa 6’da, yapay zeka uygulamaları için Lisp dilinin uygun olduğu sınıflandırılıyor.",
        },
        {
          question:
            "Bir proje için programlama dili seçiminde kritik bir faktör nedir?",
          options: [
            "Projenin genel başarısı için büyük önem taşır.",
            "Ekipmanın yaşı.",
            "Donanımın markası.",
            "Veritabanı boyutu.",
            "Yazılımın yalnızca hızı.",
          ],
          correct: 0,
          explanation:
            "Sayfa 7’de, dil seçiminin projenin genel başarısı için büyük önem taşıdığı ifade ediliyor.",
        },
        {
          question: "Veri Tabanı Yönetim Sistemi (VTYS) nedir?",
          options: [
            "Donanımı kontrol eden bir sistemdir.",
            "Yazılım kodunu makine diline çeviren bir araçtır.",
            "Veritabanlarını tanımlamak, oluşturmak ve işletimsel gereksinimleri karşılamak için tasarlanmış bir sistemdir.",
            "Kodlama stilini düzenleyen bir araçtır.",
            "Programlama dillerini optimize eden bir yazılımdır.",
          ],
          correct: 2,
          explanation:
            "Sayfa 8’de, VTYS’nin veritabanlarını tanımlamak, oluşturmak, kullanmak ve işletimsel gereksinimleri karşılamak için tasarlandığı belirtiliyor.",
        },
        {
          question: "Hazır program kütüphaneleri hakkında ne söylenebilir?",
          options: [
            "Yazılımın hızını düşürür.",
            "Günümüzde bu kütüphanelerin temin edilmesi internet üzerinden oldukça kolaydır.",
            "Kodlama stilini düzenlemek için kullanılır.",
            "Yalnızca C dilinde bulunur.",
            "Donanım uyumluluğunu test eder.",
          ],
          correct: 1,
          explanation:
            "Sayfa 9’da, günümüzde bu kütüphanelerin internet üzerinden temin edilmesinin oldukça kolay olduğu ifade ediliyor.",
        },
        {
          question: "CASE araçlarının temel işlevi nedir?",
          options: [
            "Makine kodunu doğrudan üretir.",
            "Yazılımı otomatik olarak test eder.",
            "Donanım tasarımını optimize eder.",
            "Yazılım geliştirme sürecinin her aşamasında üretilen belgelerin saklanmasını sağlar.",
            "Programlama dilini seçer.",
          ],
          correct: 3,
          explanation:
            "Sayfa 10’da, CASE araçlarının yazılım geliştirme sürecinde üretilen belgelerin saklanmasına ve yönetilmesine olanak sağladığı açıklanıyor.",
        },
        {
          question: "Kod çevirim işlemi nedir?",
          options: [
            "Veritabanını tasarlayan bir süreçtir.",
            "Kodun donanıma uygun hale getirilmesidir.",
            "Belgeleme sürecinin bir parçasıdır.",
            "Yazılımın hızını artırmak için yapılan bir işlemdir.",
            "Fiziksel prosedüre ait adımların mantıksal eşdeğerinin üretilmesidir.",
          ],
          correct: 4,
          explanation:
            "Sayfa 11’de, kod çevirim işleminin fiziksel prosedüre ait adımların mantıksal eşdeğerini üretmek olduğu tanımlanıyor.",
        },
        {
          question: "Derleyici (Compiler) ne yapar?",
          options: [
            "Bir bilgisayar dilinde yazılmış kodu makine diline çevirir.",
            "Kodlama stilini düzenler.",
            "Kod satırlarını doğrudan yürütür.",
            "Yazılımın veritabanını tasarlar.",
            "Donanımı optimize eder.",
          ],
          correct: 0,
          explanation:
            "Sayfa 12’de, derleyicinin yazılan kodu makine diline çevirdiği belirtiliyor.",
        },
        {
          question:
            "Yorumlayıcı (Interpreter) ile derleyici arasındaki temel fark nedir?",
          options: [
            "Yorumlayıcı, donanımı kontrol eder.",
            "Yorumlayıcı, kaynak kodunu satır satır yürütür.",
            "Yorumlayıcı, kodu makine diline çevirir.",
            "Yorumlayıcı, veritabanını yönetir.",
            "Yorumlayıcı, kodlama stilini düzenler.",
          ],
          correct: 1,
          explanation:
            "Sayfa 13’te, yorumlayıcının kaynak kodunu derlemek yerine satır satır yürüttüğü açıklanıyor.",
        },
        {
          question: "Kodlama sırasında belirli bir düzenin önemi nedir?",
          options: [
            "Donanım uyumluluğunu sağlar.",
            "Veritabanı tasarımını kolaylaştırır.",
            "Yazılımın yaşam döngüsü açısından önem kazanmaktadır.",
            "Belgeleme sürecini ortadan kaldırır.",
            "Yalnızca hızı etkiler.",
          ],
          correct: 2,
          explanation:
            "Sayfa 14’te, yazılımın belirli bir düzende kodlanmasının yaşam döngüsü açısından önemli olduğu belirtiliyor.",
        },
        {
          question: "Etkin kod yazılım stili için hangi yöntem kullanılmaz?",
          options: [
            "Açıklamalar",
            "Kodlama dili",
            "Donanım testi",
            "Kod belgeleme",
            "İsimlendirme",
          ],
          correct: 2,
          explanation:
            "Sayfa 14’te, etkin kod stili için kodlama dili, kod belgeleme, isimlendirme ve açıklamalar listeleniyor, ancak ‘donanım testi’ yer almıyor.",
        },
        {
          question:
            "Kodlama satırlarında modül başlangıcında hangi bilgi yer almaz?",
          options: [
            "Desteklenen platformlar",
            "Donanım gereksinimleri",
            "Genel amaç",
            "İşlevi",
            "Eksikler",
          ],
          correct: 1,
          explanation:
            "Sayfa 15’te, modül başlangıcında genel amaç, işlevi, desteklenen platformlar ve eksikler listeleniyor, ancak ‘donanım gereksinimleri’ belirtilmiyor.",
        },
        {
          question: "Kod biçimlemesi neden önemlidir?",
          options: [
            "Donanım uyumluluğunu sağlar.",
            "Veritabanı yönetimini kolaylaştırır.",
            "Kodun boyutunu küçültür.",
            "Yazılımın hızını artırır.",
            "Programın okunabilirliğini ve anlaşılabilirliğini artırmak amacıyla kullanılır.",
          ],
          correct: 4,
          explanation:
            "Sayfa 16’da, kod biçimlemesinin açıklama satırlarıyla birlikte programın okunabilirliğini ve anlaşılabilirliğini artırdığı belirtiliyor.",
        },
        {
          question: "Anlamlı isimlendirme neden önemlidir?",
          options: [
            "Anlaşılabilirliği büyük ölçüde etkilemektedir.",
            "Kodun boyutunu küçültür.",
            "Yazılımın hızını artırır.",
            "Veritabanı yönetimini kolaylaştırır.",
            "Donanım uyumluluğunu sağlar.",
          ],
          correct: 0,
          explanation:
            "Sayfa 17’de, anlamlı isimlendirmenin anlaşılabilirliği büyük ölçüde etkilediği ifade ediliyor.",
        },
        {
          question: "Yapısal programlama yapıları hangi özelliği taşımaz?",
          options: [
            "Ardışıl işlem yapıları içerir.",
            "Goto komutları bulunur.",
            "Tek giriş ve tek çıkışlı öbeklerden oluşur.",
            "Koşullu işlem yapıları içerir.",
            "Döngü yapıları içerir.",
          ],
          correct: 1,
          explanation:
            "Sayfa 18’de, yapısal programlama yapılarının içinde goto komutlarının bulunmadığı belirtiliyor.",
        },
        {
          question: "Kod etkinliğini artırmak için hangi yöntem önerilmez?",
          options: [
            "İşaretçi (pointer) mümkün olduğunca kullanılmalıdır.",
            "Etkinliği düşürecek veri yapılarından kaçınılmalıdır.",
            "Her zaman uzun yordamlar tercih edilmelidir.",
            "Aritmetik işlem hazırlığı",
            "Uzun yordamlar kullanılmamalıdır.",
          ],
          correct: 2,
          explanation:
            "Sayfa 19’da, uzun yordamların kullanılmaması gerektiği belirtiliyor, bu nedenle ‘her zaman uzun yordamlar tercih edilmelidir’ önerilmez.",
        },
        {
          question: "Bellek etkinliğini artırmak için ne yapılmalıdır?",
          options: [
            "Veri tipi tanımlanmaz.",
            "Statik bellek her zaman tercih edilmeli.",
            "Kullanımı olmayan alanlar dahil edilmeli.",
            "Dinamik bellek kullanılmalı.",
            "Bellek hiyerarşisi göz ardı edilmeli.",
          ],
          correct: 3,
          explanation:
            "Sayfa 20’de, sık ekleme ve çıkarma yapılan veri yapılarında dinamik bellek kullanılması gerektiği belirtiliyor.",
        },
        {
          question: "Giriş/çıkış etkinliği için hangi kural geçerli değildir?",
          options: [
            "Veri türü ve büyüklüğü istek sıklığına göre optimize edilmelidir.",
            "İletişim yükünü artırmak için tamponlama yapılmalıdır.",
            "Giriş/çıkış istekleri en düşük düzeyde tutulmalıdır.",
            "Veri doğruluğu kontrol edilmelidir.",
            "Dışardan gelen veriler test edilmelidir.",
          ],
          correct: 1,
          explanation:
            "Sayfa 21’de, iletişim yükünü azaltmak için tamponlama yapılması gerektiği belirtiliyor, bu nedenle ‘artırmak’ yanlış bir ifadedir.",
        },
        {
          question: "Atık toplama (garbage collection) nedir?",
          options: [
            "Kodlama stilini düzenleyen bir araçtır.",
            "Veritabanını optimize eden bir yöntemdir.",
            "Kullanımı sona eren nesne ve veri yapılarının silinmesidir.",
            "Kodun hızını artırmak için yapılan bir işlemdir.",
            "Donanımı kontrol eden bir süreçtir.",
          ],
          correct: 2,
          explanation:
            "Sayfa 22’de, atık toplamanın kullanımı sona eren nesne ve veri yapılarının silinmesi olduğu tanımlanıyor.",
        },
        {
          question: "Aykırı durumların kotarılması neyi ifade eder?",
          options: [
            "Kodun boyutunu küçülten bir işlemdir.",
            "Programın denetim dışında sonlanmasına neden olan durumdur.",
            "Yazılımın hızını artıran bir yöntemdir.",
            "Veritabanı yönetimini kolaylaştıran bir süreçtir.",
            "Donanım uyumluluğunu sağlayan bir araçtır.",
          ],
          correct: 1,
          explanation:
            "Sayfa 23’te, aykırı durumların programın denetim dışında sonlanmasına neden olduğu belirtiliyor.",
        },
        {
          question: "Kod gözden geçirme neden gereklidir?",
          options: [
            "Yazılımın hızını artırır.",
            "Kod gözden geçirme olmadan yazılım sistemi geliştirilemez.",
            "Donanım uyumluluğunu sağlar.",
            "Veritabanı tasarımını kolaylaştırır.",
            "Kodun boyutunu küçültür.",
          ],
          correct: 1,
          explanation:
            "Sayfa 25’te, kod gözden geçirme olmadan yazılım sistemi geliştirilemeyeceği ifade ediliyor.",
        },
        {
          question: "Belgeleme için gerekli dökümanlardan biri hangisidir?",
          options: [
            "Donanım Test Planı",
            "Software Requirements Specification",
            "Kodlama Stili Kılavuzu",
            "Veritabanı Optimizasyon Raporu",
            "Yazılım Hız Testi",
          ],
          correct: 1,
          explanation:
            "Sayfa 26’da, Software Requirements Specification belgeleme için gerekli dökümanlar arasında listeleniyor.",
        },
        {
          question: "Dahili dokümantasyon neyi içerir?",
          options: [
            "Kullanım kılavuzları",
            "Kurulum talimatları",
            "Kaynak kodundaki yorumlar",
            "Donanım gereksinimleri",
            "Veritabanı tasarımı",
          ],
          correct: 2,
          explanation:
            "Sayfa 27’de, dahili dokümantasyonun kaynak kodundaki yorumları içerdiği belirtiliyor.",
        },
        {
          question: "Teknik yazı neden kullanılır?",
          options: [
            "Yazılımın hızını artırmak için yazılır.",
            "Donanım uyumluluğunu sağlamak için hazırlanır.",
            "Kodun boyutunu küçültmek için kullanılır.",
            "Okuyucunun materyali kolay anlaması için düzenlenir.",
            "Veritabanı yönetimini kolaylaştırmak için tasarlanır.",
          ],
          correct: 3,
          explanation:
            "Sayfa 28’de, teknik yazının materyali kolay anlaşılır şekilde düzenlemek için olduğu ifade ediliyor.",
        },
        {
          question: "Yazım talimatlarında hangi kural yer almaz?",
          options: [
            "Donanım testlerini ekleyin",
            "Amaca yönelik giriş paragrafı",
            "Bireysel adımları listeleyin",
            "Her adıma komut sözcükleriyle başlayın",
            "Sayı noktaları kullanın",
          ],
          correct: 0,
          explanation:
            "Sayfa 29’da, yazım talimatları için giriş paragrafı, adımların listelenmesi, komut sözcükleri ve sayı noktaları belirtiliyor, ancak ‘donanım testleri’ yer almıyor.",
        },
        {
          question: "JAVA dili neden taşınabilir bir yapıya sahiptir?",
          options: [
            "Derleyici kullanır.",
            "Yorumlayıcı kullanması nedeniyle platform bağımsızdır.",
            "Donanıma bağımlıdır.",
            "Kodlama stili düzenlidir.",
            "Veritabanı yönetimini kolaylaştırır.",
          ],
          correct: 1,
          explanation:
            "Sayfa 13’te, JAVA dilinin yorumlayıcı kullanması nedeniyle taşınabilir (platform bağımsız) bir yapıya sahip olduğu belirtiliyor.",
        },
        {
          question: "Kodlama etkinliği neyi ifade eder?",
          options: [
            "Yazılımın hızını artırmak için yapılan bir işlemdir.",
            "Donanım uyumluluğunu sağlayan bir süreçtir.",
            "Öz kaynakların etkin ve verimli bir şekilde kullanılarak amaçlara ulaşılmasıdır.",
            "Veritabanı tasarımını kolaylaştıran bir yöntemdir.",
            "Kodun boyutunu küçülten bir araçtır.",
          ],
          correct: 2,
          explanation:
            "Sayfa 19’da, kodlama etkinliğinin öz kaynakların etkin ve verimli bir şekilde kullanılarak amaçlara ulaşılması olduğu tanımlanıyor.",
        },
        {
          question: "Belgeye göre yazılım testinin temel amacı nedir?",
          options: [
            "Yazılımın kusurlarını bulmak ve kullanıcıya teslim etmeden önce çalıştırmaktır.",
            "Yazılımın hızını artırmak için optimizasyon yapmaktır.",
            "Donanımı test etmek ve uyumluluğunu sağlamaktır.",
            "Kodlama hatalarını yalnızca derleyici ile düzeltmektir.",
            "Veritabanı tasarımını doğrulamaktır.",
          ],
          correct: 0,
          explanation:
            "Sayfa 6’da, yazılım testinin en genel şekliyle bir yazılım sistemini veya birimini kullanıcıya teslim etmeden önce kusur bulmak amacıyla çalıştırmak olduğu belirtiliyor.",
        },
      ];
      const questionsModel5 = [
        {
          question:
            "Yazılım geliştirmede hataların oluşmasını engellemek için ne yapılır?",
          options: [
            "Yazılım yalnızca kodlama aşamasında test edilir.",
            "Nitelik güvence etkinlikleriyle beraber yürütülür.",
            "Hatalar yalnızca kullanıcı tarafından bulunur.",
            "Tasarım aşaması tamamen atlanır.",
            "Kodlama otomatik araçlarla yapılır.",
          ],
          correct: 1,
          explanation:
            "Sayfa 2’de, hataların oluşmaması ve oluşanların ortadan kaldırılması için yazılım geliştirme işlerinin nitelik güvence etkinlikleriyle beraber yürütüldüğü ifade ediliyor.",
        },
        {
          question:
            "Yazılım testi hangi aşamaların son değerlendirmesi olarak kabul edilir?",
          options: [
            "Donanım tasarımı ve üretimi",
            "Veritabanı optimizasyonu",
            "Çözümleme, tasarım ve kodlama",
            "Kullanıcı eğitimi",
            "Belgeleme ve raporlama",
          ],
          correct: 2,
          explanation:
            "Sayfa 3’te, yazılım testinin çözümleme, tasarım ve kodlama aşamalarının son bir değerlendirmesi yerine geçtiği belirtiliyor.",
        },
        {
          question:
            "Yazılım testinin tarihsel gelişiminde 1980’li yıllardan sonra ne değişti?",
          options: [
            "Testler yalnızca hata bulma amacıyla yapılmaya başlandı.",
            "Testler tamamen otomatik hale geldi.",
            "Donanım testleri öncelik kazandı.",
            "Daha kuralı geliştirme teknikleriyle aşamalı testler kullanılmaya başlandı.",
            "Testler yalnızca kullanıcı tarafından yapıldı.",
          ],
          correct: 3,
          explanation:
            "Sayfa 4’te, 1980’li yıllardan sonra daha kuralı geliştirme teknikleri kullanılarak tüm geliştirme sürecini içeren aşamalı testlerin uygulanmaya başlandığı belirtiliyor.",
        },
        {
          question: "Test senaryoları nasıl hazırlanmalıdır?",
          options: [
            "Yazılımın hızını artırmak için optimize edilmelidir.",
            "Donanım uyumluluğunu test etmek için tasarlanmalıdır.",
            "Kodlama hatalarını bulmak için rastgele oluşturulmalıdır.",
            "Gerçek koşulları düşünerek sistemin isterlerini karşılayıp karşılamadığını göstermelidir.",
            "Kullanıcı tarafından onaylanmadan hazırlanmalıdır.",
          ],
          correct: 3,
          explanation:
            "Sayfa 5’te, test senaryolarının gerçek koşulları düşünülerek sistemin isterlerini karşılayıp karşılamadığını göstermek üzere hazırlanması gerektiği ifade ediliyor.",
        },
        {
          question: "Deneme testlerinin temel amaçlarından biri hangisidir?",
          options: [
            "Birimin tüm isterleri karşıladığını denemek.",
            "Yazılımın yalnızca hızını ölçmek.",
            "Donanımın güvenilirliğini test etmek.",
            "Kullanıcı arayüzünü tasarlamak.",
            "Veritabanı performansını değerlendirmek.",
          ],
          correct: 0,
          explanation:
            "Sayfa 7’de, deneme testlerinin amaçları arasında birimin tüm isterleri karşıladığının denenmesi yer alıyor.",
        },
        {
          question: "Kabul testleri hangi amaçla yapılır?",
          options: [
            "Kodlama hatalarını bulmak için.",
            "Yazılımın doğru çalıştığını kullanıcıya veya temsilcisine göstermek için.",
            "Donanımın performansını ölçmek için.",
            "Tasarım belgelerini doğrulamak için.",
            "Veritabanı yapısını test etmek için.",
          ],
          correct: 1,
          explanation:
            "Sayfa 8’de, kabul testlerinin yazılımın doğru çalıştığını kullanıcıya veya temsilcisine göstermek amacıyla yapıldığı belirtiliyor.",
        },
        {
          question:
            "Kabul testlerinde sistemin güvenilirliğini kanıtlamak için ne yapılır?",
          options: [
            "Sistem olabildiğince ağır yükte ve en kötü koşullarda çalıştırılır.",
            "Yazılım yalnızca laboratuvar ortamında test edilir.",
            "Kullanıcı arayüzü optimize edilir.",
            "Kodlama hataları derleyici ile düzeltilir.",
            "Donanım tasarımı gözden geçirilir.",
          ],
          correct: 0,
          explanation:
            "Sayfa 9’da, sistemin ağır yükte ve en kötü koşullarda çalıştırılarak güvenilirliğinin kanıtlandığı ifade ediliyor.",
        },
        {
          question:
            "Yazılım testinin yapılabilmesi için hangi girdilerden biri gereklidir?",
          options: [
            "Donanım üretim planı",
            "Kullanıcı eğitim kılavuzu",
            "Test tanımlaması (test senaryolarını ayrıntılı olarak anlatır)",
            "Kodlama stili rehberi",
            "Veritabanı optimizasyon raporu",
          ],
          correct: 2,
          explanation:
            "Sayfa 10’da, test tanımlamasının (test senaryolarını ayrıntılı olarak anlatır) yazılım testinin yapılabilmesi için gerekli girdilerden biri olduğu belirtiliyor.",
        },
        {
          question: "Test değerlendirmesi sonucunda ne olabilir?",
          options: [
            "Yazılımın yeterliliğine kanaat getirilir veya hatalar için üreticiye geri verilir.",
            "Yazılım otomatik olarak optimize edilir.",
            "Donanım tasarımı yeniden yapılır.",
            "Kullanıcı arayüzü yeniden tasarlanır.",
            "Veritabanı yapısı değiştirilir.",
          ],
          correct: 0,
          explanation:
            "Sayfa 12’de, test değerlendirmesi sonunda yazılımın yeterli niteliğe sahip olduğuna kanaat getirilebileceği veya hatalar için üreticiye geri verilebileceği belirtiliyor.",
        },
        {
          question: "Saydam kutu testi (white-box test) hangi özelliği içerir?",
          options: [
            "Yazılımın iç yapısı göz ardı edilir.",
            "Bütün bağımsız yolların en az bir kez sınanması gerekir.",
            "Yalnızca kullanıcı arayüzü test edilir.",
            "Donanım performansı ölçülür.",
            "Veritabanı bağlantıları kontrol edilir.",
          ],
          correct: 1,
          explanation:
            "Sayfa 16’da, saydam kutu testinde bütün bağımsız yolların en az bir kez sınanması gerektiği ifade ediliyor.",
        },
        {
          question: "Kara kutu testi (black-box test) hangi düzeyde yapılır?",
          options: [
            "Kodlama düzeyinde",
            "Donanım düzeyinde",
            "Yazılımın ara yüzü düzeyinde",
            "Veritabanı düzeyinde",
            "Tasarım düzeyinde",
          ],
          correct: 2,
          explanation:
            "Sayfa 25’te, kara kutu testinin yazılımın ara yüzü düzeyinde yapıldığı belirtiliyor.",
        },
        {
          question: "Tasarım tabanlı testlerde modüller nasıl kabul edilir?",
          options: [
            "Donanım birimleri olarak",
            "Kara kutu olarak",
            "Saydam kutu olarak",
            "Veritabanı birimleri olarak",
            "Kodlama birimleri olarak",
          ],
          correct: 1,
          explanation:
            "Sayfa 18’de, tasarım tabanlı testlerde modüllerin birer kara kutu olarak kabul edilerek test edildiği ifade ediliyor.",
        },
        {
          question: "Kod tabanlı test neden gereklidir?",
          options: [
            "Yazılımın hızını artırmak için",
            "Donanım uyumluluğunu sağlamak için",
            "Kara kutu testinin güvenilirliği kanıtlamayabileceği durumlar için",
            "Kullanıcı arayüzünü test etmek için",
            "Veritabanı performansını ölçmek için",
          ],
          correct: 2,
          explanation:
            "Sayfa 20’de, yalnızca kara kutu testinin yazılım biriminin güvenilirliğini kanıtlamayabileceği durumlar için kod tabanlı testin gerektiği belirtiliyor.",
        },
        {
          question: "Mantık hatalarının bir nedeni nedir?",
          options: [
            "Donanım arızaları",
            "Veritabanı bağlantı sorunları",
            "Bir değişkene ilk değer verilmemesi",
            "Kullanıcı arayüzü tasarımı",
            "Derleyici optimizasyonu",
          ],
          correct: 2,
          explanation:
            "Sayfa 21’de, mantık hatalarının nedenleri arasında bir değişkene ilk değer verilmemesi yer alıyor.",
        },
        {
          question: "Kodlama hatalarına örnek olarak ne verilebilir?",
          options: [
            "Dizi boyunun aşılması",
            "Donanım uyumsuzluğu",
            "Veritabanı bağlantı kesintisi",
            "Kullanıcı arayüzü çökmesi",
            "Tasarım belgelerindeki eksiklik",
          ],
          correct: 0,
          explanation:
            "Sayfa 22’de, kodlama hatalarına örnek olarak dinamik veri yapılarında dizi boyunun aşılması veriliyor.",
        },
        {
          question: "Akış yolu varsayımı neden tehlikelidir?",
          options: [
            "Yazılımın hızını düşürür.",
            "Farklı bir akış yolunun izlenmesi hataya neden olabilir.",
            "Donanım uyumluluğunu bozar.",
            "Veritabanı performansını etkiler.",
            "Kullanıcı arayüzünü karmaşıklaştırır.",
          ],
          correct: 1,
          explanation:
            "Sayfa 23’te, farklı bir akış yolunun izlenmesinin yazılımın hata üretmesine neden olabileceği belirtiliyor.",
        },
        {
          question: "Yazım hatalarını kim yakalar?",
          options: [
            "Kullanıcı",
            "Test personeli",
            "Derleyici",
            "Donanım",
            "Veritabanı yöneticisi",
          ],
          correct: 2,
          explanation:
            "Sayfa 24’te, günümüzde kullanılan birçok derleyicinin kod yazım hatalarını yakaladığı ve hata verdiği ifade ediliyor.",
        },
        {
          question: "Gömülü sistemlerin testinde ne önemlidir?",
          options: [
            "Yazılımların donanımla birlikte test edilmesi",
            "Yalnızca yazılımın test edilmesi",
            "Veritabanı bağlantılarının kontrol edilmesi",
            "Kullanıcı arayüzünün optimize edilmesi",
            "Donanımın ayrı test edilmesi",
          ],
          correct: 0,
          explanation:
            "Sayfa 29’da, gömülü sistemlerin yazılımlarının donanıma kumanda ettiği için donanımla birlikte test edilmesi gerektiği belirtiliyor.",
        },
        {
          question: "Gerçek zamanlı sistemlerin testi nasıl yapılır?",
          options: [
            "Yalnızca laboratuvar ortamında",
            "Çok özel benzetim ortamlarında veya gerçek sistem üzerinde",
            "Kullanıcı arayüzü üzerinden",
            "Donanım olmadan",
            "Veritabanı bağlantılarıyla",
          ],
          correct: 1,
          explanation:
            "Sayfa 30’da, gerçek zamanlı sistemlerin yazılımının çok özel benzetim ortamlarında veya gerçek sistem üzerinde test edildiği ifade ediliyor.",
        },
        {
          question: "Büyük veritabanı sistemleri için test neden önemlidir?",
          options: [
            "Donanım uyumluluğunu sağlamak için",
            "Kullanıcı arayüzünü optimize etmek için",
            "Çok ayrıntılı ve hassas testten geçirilmesi gerektiği için",
            "Yazılımın hızını artırmak için",
            "Kodlama hatalarını derleyici ile düzeltmek için",
          ],
          correct: 2,
          explanation:
            "Sayfa 32’de, büyük veritabanı sistemlerinin tam kullanıma sunulmadan önce çok ayrıntılı ve hassas testten geçirilmesi gerektiği belirtiliyor.",
        },
        {
          question: "Güvenlik sistemlerinin testi hangi özelliği içermelidir?",
          options: [
            "Yazılımın hızını artırmalıdır.",
            "Donanım uyumluluğunu sağlamalıdır.",
            "Her türlü olağan dışı olayı tespit edebilmeli ve yanlış alarm üretmemelidir.",
            "Kullanıcı arayüzünü optimize etmelidir.",
            "Veritabanı performansını ölçmelidir.",
          ],
          correct: 2,
          explanation:
            "Sayfa 33’te, güvenlik sistemlerinin her türlü olağan dışı olayı tespit edebilmesi ve yanlış alarm üretmemesi gerektiği ifade ediliyor.",
        },
        {
          question:
            "Otomatik test araçlarından ‘duragan çözümleyiciler’ ne yapar?",
          options: [
            "Yazılımın hızını ölçer.",
            "Donanım uyumluluğunu test eder.",
            "Kaynak kodunu inceleyerek zayıf noktaları bulur ve uyarı verir.",
            "Kullanıcı arayüzünü optimize eder.",
            "Veritabanı bağlantılarını kontrol eder.",
          ],
          correct: 2,
          explanation:
            "Sayfa 36’da, duragan çözümleyicilerin kaynak kodunu inceleyerek yapısındaki zayıf noktaları bulduğu ve uyarı verdiği belirtiliyor.",
        },
        {
          question: "Birim testi (unit test) hangi yöntemi sıkça kullanır?",
          options: [
            "Kara kutu yöntemini",
            "Saydam kutu yöntemini",
            "Donanım test yöntemini",
            "Veritabanı test yöntemini",
            "Kullanıcı arayüzü test yöntemini",
          ],
          correct: 1,
          explanation:
            "Sayfa 40’ta, birim testinde daha çok saydam kutu yönteminin kullanıldığı ifade ediliyor.",
        },
        {
          question: "Tümleştirme testinin bir amacı nedir?",
          options: [
            "Birimlerin ağ üzerindeki iletişim sorunlarını kontrol etmek",
            "Yazılımın hızını artırmak",
            "Donanımın performansını ölçmek",
            "Kullanıcı arayüzünü optimize etmek",
            "Veritabanı bağlantılarını test etmek",
          ],
          correct: 0,
          explanation:
            "Sayfa 44’te, tümleştirme testinin birimlerin ağ üzerindeki iletişim sorunlarını kontrol ettiği belirtiliyor.",
        },
        {
          question: "Yukarıdan aşağıya tümleştirme testinde ne kullanılır?",
          options: [
            "Gerçek birimler hemen test edilir.",
            "Tüm birimler aynı anda test edilir.",
            "Geçici kod parçaları veya sürücüler kullanılır.",
            "Yalnızca donanım test edilir.",
            "Veritabanı bağlantıları kontrol edilir.",
          ],
          correct: 2,
          explanation:
            "Sayfa 45’te, yukarıdan aşağıya tümleştirmede geçici kod parçaları veya sürücülerin kullanıldığı ifade ediliyor.",
        },
        {
          question: "Doğrulama (verification) neyi amaçlar?",
          options: [
            "Yazılımın hızını artırmayı",
            "Donanım uyumluluğunu sağlamayı",
            "Bir yazılım ürününün belirli işlevleri doğru gerçekleştirdiğinden emin olmayı",
            "Kullanıcı arayüzünü optimize etmeyi",
            "Veritabanı performansını ölçmeyi",
          ],
          correct: 2,
          explanation:
            "Sayfa 50’de, doğrulamanın bir yazılım ürününün belirli işlevleri doğru gerçekleştirdiğinden emin olmak için yapıldığı belirtiliyor.",
        },
        {
          question: "Geçerleme (validation) neyi içerir?",
          options: [
            "Yazılımın doğru amaç için geliştirildiğinin denenmesini",
            "Donanımın performansının ölçülmesini",
            "Kodlama hatalarının derleyici ile düzeltilmesini",
            "Kullanıcı arayüzünün optimize edilmesini",
            "Veritabanı bağlantılarının kontrol edilmesini",
          ],
          correct: 0,
          explanation:
            "Sayfa 51’de, geçerlemenin yazılımın doğru amaç için geliştirildiğinin gerçek ortamda denenerek doğruluğuna kanaat getirilmesi olduğu ifade ediliyor.",
        },
        {
          question: "Rasgele testler neden yapılır?",
          options: [
            "Donanım uyumluluğunu test etmek için",
            "Önceden tahmin edilemeyen durumları gerçekleştirmek için",
            "Yazılımın hızını ölçmek için",
            "Kullanıcı arayüzünü optimize etmek için",
            "Veritabanı performansını değerlendirmek için",
          ],
          correct: 1,
          explanation:
            "Sayfa 53’te, rasgele testlerin önceden tahmin edilemeyen durumları gerçekleştirmek için yapıldığı belirtiliyor.",
        },
        {
          question: "Alfa testi ile beta testi arasındaki fark nedir?",
          options: [
            "Alfa testi geliştiricinin yerinde, beta testi kullanıcının ortamında yapılır.",
            "Alfa testi donanım, beta testi yazılım içindir.",
            "Alfa testi veritabanı, beta testi arayüz içindir.",
            "Alfa testi hız, beta testi performans içindir.",
            "Alfa testi kodlama, beta testi tasarım içindir.",
          ],
          correct: 0,
          explanation:
            "Sayfa 56’da, alfa testinin geliştiricinin yerinde bir müşteri tarafından yapıldığı, beta testinin ise kullanıcının kendi ortamında yapıldığı belirtiliyor.",
        },
      ];

      const questionsModel6 = [
        {
          question: "Yaz - Yazılım bakımı ne zaman başlar?",
          options: [
            "Bilgisayar tabanlı sistemlerin tasarlanıp geliştirilip kullanıcıya tesliminden sonra.",
            "Yazılım geliştirme sürecinin başında.",
            "Yazılımın test aşamasında.",
            "Kullanıcı sorun bildirdiğinde.",
            "Donanım değiştiğinde.",
          ],
          correct: 0,
          explanation:
            "pdf 6’da, sayfa 3’te, bilgisayar tabanlı sistemlerin tasarlanıp geliştirilmesinden ve kullanıcıya tesliminden sonra bakım aşamasının başladığı belirtiliyor.",
        },
        {
          question: "Yazılım bakımının temelini ne oluşturur?",
          options: [
            "Yazılımın hızını artırmak.",
            "Zaman içinde ortaya çıkan yeni isterlerin karşılanması veya hataların giderilmesi.",
            "Donanımın güncellenmesi.",
            "Kullanıcı arayüzünün iyileştirilmesi.",
            "Veritabanı optimizasyonu.",
          ],
          correct: 1,
          explanation:
            "pdf 6’da, sayfa 3’te, zaman içinde ortaya çıkan yeni isterlerin karşılanması veya bulunan hataların giderilmesi çalışmalarının yazılım bakımının temellerini oluşturduğu ifade ediliyor.",
        },
        {
          question: "Düzeltici (corrective) bakım neyi kapsar?",
          options: [
            "Yazılımın yeni donanıma uyarlanması.",
            "Yeni işlevler eklenmesi.",
            "Kusurların giderilmesi için yapılan işler.",
            "Yazılımın güvenilirliğini artırmak.",
            "Kullanıcı arayüzünün güncellenmesi.",
          ],
          correct: 2,
          explanation:
            "pdf 6’da, sayfa 5’te, geliştirici tarafından kusurun kaynaklanma sebebini araştırmaya ve gidermeye yönelik yürütülen işlerin düzeltici (corrective) bakım olarak adlandırıldığı belirtiliyor.",
        },
        {
          question: "Uyarlayıcı (adaptive) bakım hangi durumda yapılır?",
          options: [
            "Yazılım kusurları giderildiğinde.",
            "Yeni işlevler eklendiğinde.",
            "Yazılımın güvenilirliği artırıldığında.",
            "Yeni donanım veya işletim sistemlerine uyarlama yapıldığında.",
            "Kullanıcı arayüzü iyileştirildiğinde.",
          ],
          correct: 3,
          explanation:
            "pdf 6’da, sayfa 6’da, yazılımın yeni donanıma, işletim sistemlerine veya bunların yeni sürümlerine uyarlanması işlerinin uyarlayıcı (adaptive) bakım olarak tanımlandığı belirtiliyor.",
        },
        {
          question: "İyileştirici (perfective) bakımın sonucu nedir?",
          options: [
            "Yazılımın yeni bir sürümünün ortaya çıkması.",
            "Hataların giderilmesi.",
            "Donanımın güncellenmesi.",
            "Kullanıcı arayüzünün değişmesi.",
            "Veritabanının optimize edilmesi.",
          ],
          correct: 0,
          explanation:
            "pdf 6’da, sayfa 7’de, iyileştirici (perfective) bakım sonucunda yazılımın yeni bir sürümünün ortaya çıktığı ve kullanıcıya sunulduğu ifade ediliyor.",
        },
        {
          question:
            "Sürüm numaralandırma şemasında 'major' numarası ne zaman artırılır?",
          options: [
            "Köklü değişiklikler veya yeni bir ortama uyarlamalar sonrası.",
            "Yeni bir özellik eklendiğinde.",
            "Bir hata giderildiğinde.",
            "Önemsiz bir değişiklik yapıldığında.",
            "Kullanıcı arayüzü güncellendiğinde.",
          ],
          correct: 0,
          explanation:
            "pdf 6’da, sayfa 8’de, 'major' numarasının yazılımdaki köklü değişiklikler veya yeni bir ortama uyarlamalar sonrası artırıldığı belirtiliyor.",
        },
        {
          question:
            "Sürüm numaralandırma şemasında 'minor' numarası ne zaman artırılır?",
          options: [
            "Bir hata giderildiğinde.",
            "Yeni bir özellik eklendiğinde.",
            "Köklü değişiklikler yapıldığında.",
            "Önemsiz bir değişiklik yapıldığında.",
            "Donanım güncellendiğinde.",
          ],
          correct: 1,
          explanation:
            "pdf 6’da, sayfa 8’de, 'minor' numarasının yeni bir özellik eklendiğinde artırıldığı ifade ediliyor.",
        },
        {
          question:
            "Sürüm numaralandırma şemasında 'micro' numarası neyi ifade eder?",
          options: [
            "Köklü değişiklikleri.",
            "Yeni özellikleri.",
            "Bir hata giderildiğinde veya önemsiz bir değişiklik yapıldığında artar.",
            "Donanım uyarlamalarını.",
            "Kullanıcı arayüzü güncellemelerini.",
          ],
          correct: 2,
          explanation:
            "pdf 6’da, sayfa 8’de, 'micro' numarasının bir hata giderildiğinde veya önemsiz bir değişiklik yapıldığında artırıldığı belirtiliyor.",
        },
        {
          question: "'RC' (Release Candidate) etiketi neyi belirtir?",
          options: [
            "Sürümün yeterince kararlı olduğunu.",
            "Değişiklik listesinin kilitlendiğini ve yeni özellik eklenemeyeceğini.",
            "Yeni bir işlevin eklendiğini.",
            "Hataların henüz giderilmediğini.",
            "Donanımın güncellendiğini.",
          ],
          correct: 1,
          explanation:
            "pdf 6’da, sayfa 9’da, 'RC' (Release Candidate) etiketinin değişiklik listesinin kilitlendiğini ve yeni özellik eklenemeyeceğini belirttiği ifade ediliyor.",
        },
        {
          question: "'GA' (General Availability) ne anlama gelir?",
          options: [
            "Sürümün yeterince kararlı olduğunu ve production ortamına yüklenebileceğini.",
            "Yeni bir özelliğin eklendiğini.",
            "Hataların giderildiğini.",
            "Donanımın güncellendiğini.",
            "Kullanıcı arayüzünün değiştiğini.",
          ],
          correct: 0,
          explanation:
            "pdf 6’da, sayfa 10’da, 'GA' (General Availability) etiketinin sürümün yeterince kararlı olduğunu ve production ortamına yüklenebileceğini bildirdiği belirtiliyor.",
        },
        {
          question: "Önleyici (preventive) bakımın amacı nedir?",
          options: [
            "Yazılımın gelecekte uygulanabilecek değişikliklere daha iyi temel oluşturması.",
            "Hataların hemen giderilmesi.",
            "Yeni donanıma uyarlama yapılması.",
            "Kullanıcı arayüzünün iyileştirilmesi.",
            "Veritabanının optimize edilmesi.",
          ],
          correct: 0,
          explanation:
            "pdf 6’da, sayfa 11’de, önleyici (preventive) bakımın yazılımın gelecekte uygulanabilecek değişikliklere daha iyi bir temel oluşturması için yapıldığı ifade ediliyor.",
        },
        {
          question: "Bakım aşamaları hangi sürece benzer?",
          options: [
            "Donanım geliştirme sürecine.",
            "Yazılım geliştirme sürecine.",
            "Kullanıcı eğitim sürecine.",
            "Veritabanı optimizasyon sürecine.",
            "Test sürecine.",
          ],
          correct: 1,
          explanation:
            "pdf 6’da, sayfa 12’de, bakım aşamalarının tıpkı bir yazılım geliştirme sürecine benzediği belirtiliyor.",
        },
        {
          question: "Yazılım Sorun Raporu ile ne bildirilir?",
          options: [
            "Donanım sorunları.",
            "Kullanıcı arayüzü hataları.",
            "Yazılımdaki sorunlar.",
            "Veritabanı bağlantı sorunları.",
            "Test sonuçları.",
          ],
          correct: 2,
          explanation:
            "pdf 6’da, sayfa 13’te, yazılımdaki sorunların Yazılım Sorun Raporu ile bildirildiği ifade ediliyor.",
        },
        {
          question: "Yazılım Sorun Raporu’nda hangi bilgi yer almaz?",
          options: [
            "Sorunun açık tanımı.",
            "Hatalı duruma düşülmesine neden olan giriş verileri.",
            "Raporu inceleyen makamların imza ve tarihleri.",
            "Donanımın teknik özellikleri.",
            "Sistemin içinde bulunduğu durum.",
          ],
          correct: 3,
          explanation:
            "pdf 6’da, sayfa 15’te, Yazılım Sorun Raporu’nda sorunun tanımı, giriş verileri, sistem durumu gibi bilgiler yer alırken, donanımın teknik özelliklerinden bahsedilmediği belirtiliyor.",
        },
        {
          question: "Bakım kolaylığı neden önemlidir?",
          options: [
            "Değişiklikleri en düşük maliyetle ve kısa zamanda yapmak için.",
            "Yazılımın hızını artırmak için.",
            "Donanım uyumluluğunu sağlamak için.",
            "Kullanıcı arayüzünü güncellemek için.",
            "Veritabanı performansını artırmak için.",
          ],
          correct: 0,
          explanation:
            "pdf 6’da, sayfa 16’da, bakım kolaylığının değişiklikleri en düşük maliyetle, en kısa zamanda ve doğru olarak yapabilmek için önemli olduğu ifade ediliyor.",
        },
        {
          question: "Denetim etmenleri hangi kategorilere ayrılır?",
          options: [
            "Geliştirme ortamına bağlı, personele bağlı, müşteriye bağlı.",
            "Donanıma bağlı, yazılıma bağlı, testlere bağlı.",
            "Kullanıcıya bağlı, veritabanına bağlı, arayüze bağlı.",
            "Hatalara bağlı, özelliklere bağlı, sürümlere bağlı.",
            "Maliyete bağlı, zamana bağlı, niteliğe bağlı.",
          ],
          correct: 0,
          explanation:
            "pdf 6’da, sayfa 17’de, denetim etmenlerinin geliştirme ortamına bağlı, personele bağlı ve müşteriye bağlı olarak kategorize edildiği belirtiliyor.",
        },
        {
          question: "Nitelikli bir bakım evresi için ne gereklidir?",
          options: [
            "Yazılımın hızını artırmak.",
            "Bakım isteklerinin resmi bir Değişim Denetim Süreci kapsamında ele alınması.",
            "Donanımın güncellenmesi.",
            "Kullanıcı arayüzünün değişmesi.",
            "Veritabanının optimize edilmesi.",
          ],
          correct: 1,
          explanation:
            "pdf 6’da, sayfa 18’de, nitelikli bir bakım evresi için bakım isteklerinin resmi bir Değişim Denetim Süreci kapsamında ele alınması gerektiği ifade ediliyor.",
        },
        {
          question: "Bakım istekleri nasıl yerine getirilmelidir?",
          options: [
            "Yeterince hızlı olarak.",
            "Yavaş ve dikkatsizce.",
            "Donanım değişikliği ile.",
            "Kullanıcı arayüzü güncellemesi ile.",
            "Veritabanı optimizasyonu ile.",
          ],
          correct: 0,
          explanation:
            "pdf 6’da, sayfa 18’de, bakım isteklerinin yeterince hızlı olarak yerine getirilmesi gerektiği belirtiliyor.",
        },
        {
          question: "Bakım sırasında hangi standartlara uyulmalıdır?",
          options: [
            "Donanım geliştirme standartlarına.",
            "Geliştirme sürecinin belgelendirme standartlarına.",
            "Kullanıcı eğitim standartlarına.",
            "Veritabanı optimizasyon standartlarına.",
            "Test standartlarına.",
          ],
          correct: 1,
          explanation:
            "pdf 6’da, sayfa 19’da, bakım sırasında geliştirme sürecinin belgelendirme standartlarına uyulması gerektiği ifade ediliyor.",
        },
        {
          question: "Bakım sorunlarından biri nedir?",
          options: [
            "Yazılımın çok fazla sürümünün ortaya çıkması.",
            "Donanımın güncellenmesi.",
            "Kullanıcı arayüzünün değişmesi.",
            "Veritabanının optimize edilmesi.",
            "Yazılımın hızının artması.",
          ],
          correct: 0,
          explanation:
            "pdf 6’da, sayfa 20’de, yazılımın çok fazla sürümünün ortaya çıkmasının bakımı güçleştirdiği belirtiliyor.",
        },
        {
          question: "Bir başkasının yazdığı kodu anlamak neden zor olabilir?",
          options: [
            "Belgelendirme ve kod içindeki açıklamalar yetersizse.",
            "Donanım uyumsuzsa.",
            "Kullanıcı arayüzü değişmişse.",
            "Veritabanı optimize edilmişse.",
            "Yazılım hızlı çalışıyorsa.",
          ],
          correct: 0,
          explanation:
            "pdf 6’da, sayfa 20’de, bir başkasının yazdığı kodun belgelendirme ve açıklamalar yetersizse anlaşılmasının çok zaman aldığı ifade ediliyor.",
        },
        {
          question: "Yazılım modüllere ayrılmamışsa ne olur?",
          options: [
            "Sonradan değişiklik yapmak yeniden geliştirmekten zor olabilir.",
            "Yazılımın hızı artar.",
            "Donanım uyumluluğu sağlanır.",
            "Kullanıcı arayüzü iyileşir.",
            "Veritabanı performansı artar.",
          ],
          correct: 0,
          explanation:
            "pdf 6’da, sayfa 21’de, yazılım işlevsel olarak modüllere ayrılmamışsa sonradan değişiklik yapmanın yeniden geliştirmekten daha zor olabileceği belirtiliyor.",
        },
        {
          question: "Bakım istekleri için ne yapılmalıdır?",
          options: [
            "Yazılımın hızı artırılmalıdır.",
            "İsabetli işgücü gereksinimi, süre ve maliyet kestirimi yapılmalıdır.",
            "Donanım güncellenmelidir.",
            "Kullanıcı arayüzü değiştirilmelidir.",
            "Veritabanı optimize edilmelidir.",
          ],
          correct: 1,
          explanation:
            "pdf 6’da, sayfa 18’de, bakım istekleri için isabetli işgücü gereksinimi, süre ve maliyet kestirimi yapılması gerektiği ifade ediliyor.",
        },
        {
          question: "Bakım isteklerinin durumu nasıl izlenmelidir?",
          options: [
            "Sistematik olarak.",
            "Rastgele bir şekilde.",
            "Donanım değişiklikleriyle.",
            "Kullanıcı geri bildirimleriyle.",
            "Veritabanı raporlarıyla.",
          ],
          correct: 0,
          explanation:
            "pdf 6’da, sayfa 18’de, bakım isteklerinin durumunun sistematik olarak izlenmesi gerektiği belirtiliyor.",
        },
        {
          question: "Bakımda verimliliği artırmak için ne kullanılmalıdır?",
          options: [
            "Yazılımın hızını artıran araçlar.",
            "Bakımı kolaylaştırıcı yardımcı araçlar.",
            "Donanım güncelleme araçları.",
            "Kullanıcı arayüzü tasarım araçları.",
            "Veritabanı optimizasyon araçları.",
          ],
          correct: 1,
          explanation:
            "pdf 6’da, sayfa 19’da, verimliliği artırmak ve bakımı kolaylaştırmak için yardımcı araçların kullanılması gerektiği ifade ediliyor.",
        },
        {
          question: "Bakım sırasında hangi personel kullanılmalıdır?",
          options: [
            "Uygun nitelikte teknik personel.",
            "Donanım uzmanları.",
            "Kullanıcı arayüzü tasarımcıları.",
            "Veritabanı yöneticileri.",
            "Test personeli.",
          ],
          correct: 0,
          explanation:
            "pdf 6’da, sayfa 19’da, bakım işleri için uygun nitelikte teknik personel kullanılması gerektiği belirtiliyor.",
        },
        {
          question: "Yazılım Sorun Raporu’nda hangi bilgi yer alır?",
          options: [
            "Donanımın üretim tarihi.",
            "Sorunu rapor eden kişiye ait erişim bilgileri.",
            "Yazılımın hız ölçümleri.",
            "Kullanıcı arayüzü tasarımı.",
            "Veritabanı bağlantı ayarları.",
          ],
          correct: 1,
          explanation:
            "pdf 6’da, sayfa 15’te, Yazılım Sorun Raporu’nda sorunu rapor eden kişiye ait erişim bilgilerinin yer aldığı ifade ediliyor.",
        },
        {
          question: "Bakım kolaylığı nasıl sağlanır?",
          options: [
            "Yazılımın niteliklerini bozmadan değişiklik yapmakla.",
            "Yazılımın hızını artırarak.",
            "Donanımı güncelleyerek.",
            "Kullanıcı arayüzünü değiştirerek.",
            "Veritabanını optimize ederek.",
          ],
          correct: 0,
          explanation:
            "pdf 6’da, sayfa 16’da, bakım kolaylığının yazılımın niteliklerini bozmadan değişiklik yapılmasıyla sağlandığı belirtiliyor.",
        },
        {
          question: "Bakım sırasında belgelendirme neden önemlidir?",
          options: [
            "Yazılımın hızını artırmak için.",
            "Geliştirme sürecinin standartlarına uyulması için.",
            "Donanım uyumluluğunu sağlamak için.",
            "Kullanıcı arayüzünü güncellemek için.",
            "Veritabanı performansını artırmak için.",
          ],
          correct: 1,
          explanation:
            "pdf 6’da, sayfa 19’da, bakım sırasında geliştirme sürecinin belgelendirme standartlarına uyulmasının önemli olduğu ifade ediliyor.",
        },
        {
          question: "Bakım sorunları nasıl önlenebilir?",
          options: [
            "Sorunları bilmek ve hazırlıklı olmakla.",
            "Yazılımın hızını artırarak.",
            "Donanımı güncelleyerek.",
            "Kullanıcı arayüzünü değiştirerek.",
            "Veritabanını optimize ederek.",
          ],
          correct: 0,
          explanation:
            "pdf 6’da, sayfa 20’de, bakım sırasında karşılaşılan sorunların bilinmesi ve buna karşı hazırlıklı olunmasının yararlı olduğu belirtiliyor.",
        },
      ];
      const questionsModel7 = [
        {
          question: "What is the primary function of a compiler?",
          options: [
            "To execute a program's source code line by line",
            "To translate a program written in a high-level language into machine code",
            "To manage and store software development documents",
            "To handle memory allocation for dynamic data structures",
            "To interpret code written in a scripting language",
          ],
          correct: 1,
          explanation:
            "A compiler's primary role is to translate high-level source code into machine code that a computer can execute, distinguishing it from interpreters which execute code line by line.",
        },
        {
          question:
            "Aşağıdakilerden hangisi bir yazılım test seviyesi değildir?",
          options: [
            "Birim Testi (Unit Testing)",
            "Entegrasyon Testi (Integration Testing)",
            "Sistem Testi (System Testing)",
            "Kullanıcı Kabul Testi (User Acceptance Testing)",
            "Prototip Testi (Prototype Testing)",
          ],
          correct: 4,
          explanation:
            "Prototip Testi, bir yazılım test seviyesi değildir; diğer seçenekler (Birim, Entegrasyon, Sistem ve Kullanıcı Kabul Testleri) yazılım geliştirme sürecinde standart test seviyeleridir.",
        },
        {
          question:
            "Bakım sorunları hakkında aşağıda verilen ifadelerden hangisi yanlıştır?",
          options: [
            "Bakım sırasında karşılaşabilecek sorunları bilmek o sorunlara önlem almayı kolaylaştırır.",
            "Belgelendirme ve kod içindeki açıklamalar ne kadar iyiyse bakım o kadar kolaylaşır.",
            "Yazılım sürüm sayısını artırmak bakımı zorlaştırır.",
            "Yazılım geliştirildiği süreci aynen takip etmek zaman ve iş gücünden tasarruf sağlar.",
            "Yazılım işlevsel modüllere bölmek sonradan yapılacak değişiklikleri kolaylaştırır.",
          ],
          correct: 3,
          explanation:
            "Yazılım geliştirildiği süreci aynen takip etmek genellikle bakımda tasarruf sağlamaz, çünkü zamanla değişen gereksinimler ve teknolojiler eski süreci geçersiz kılabilir.",
        },
        {
          question:
            "Aşağıdaki ifadelerden hangisi, Yazılım Geliştirme Yaşam Döngüsü'nün 'Spiral Model' ile ilgili doğru bir açıklama yapmaktadır?",
          options: [
            "Spiral Model, yalnızca yazılımın kodlama ve test aşamalarını içerir ve diğer aşamaları dışlar.",
            "Spiral Model, her aşamada müşteri geri bildirimlerini dikkate almaz ve tamamen iç geliştirme süreçlerine odaklanır.",
            "Spiral Model, yazılım geliştirme sürecinde risk analizi ve yönetimini önemli bir odak noktası olarak belirler.",
            "Spiral Model, yazılım geliştirme sürecini bir dizi kısa, sabit süreli iterasyonlara böler ve her iterasyon sonunda çalışma yazılımı teslim eder.",
            "Spiral Model, Çağlayan modeli gibi katı aşamaların sırasını takip eder ve geri dönüşlere izin vermez.",
          ],
          correct: 2,
          explanation:
            "Spiral Model, risk analizi ve yönetimine odaklanır, bu da onu diğer modellerden ayıran temel özelliktir.",
        },
        {
          question: "Hangi modelde Risk Analizi Olgusu ön plana çıkmıştır?",
          options: [
            "Helezonoik model",
            "Çağlayan model",
            "V model",
            "Evrimsel geliştirme süreç modeli",
            "Gelişigüzel model",
          ],
          correct: 0,
          explanation:
            "Helezonoik model (Spiral Model), risk analizini merkeze alır ve bu özelliğiyle öne çıkar.",
        },
        {
          question:
            "Aşağıdakilerden hangisi Uç Programlama modelinin 12 Yöntemlerinden birisi değildir?",
          options: [
            "Çifte Programlama (Pair Programming)",
            "Plan Oyunu (The Planning Game)",
            "Metafor (Metaphor)",
            "Çifte Test (Pair Testing)",
            "Yerinde müşteri (On-Site Customer)",
          ],
          correct: 3,
          explanation:
            "Çifte Test (Pair Testing), Extreme Programming’in 12 yönteminden biri değildir; diğerleri bu metodolojinin temel prensiplerindendir.",
        },
        {
          question:
            "Aşağıdakilerden hangisi doğru bir Sürüm Numaralandırma örneğidir?",
          options: [
            "1.0.0-M1 -> 1.0.0-RC1 -> 1.0.0-M2 -> 1.0.0-RC2 -> 1.0.0 -> 1.1.0",
            "2.0.0-RC1 -> 2.0.0-RC2 -> 2.0.0-M1 -> 2.0.0-M2 -> 2.0.0 -> 2.0.1",
            "1.0.0-M1 -> 2.0.0-M2 -> 2.1.0-RC1 -> 2.2.0-RC2 -> 2.2.0 -> 2.3.0",
            "2.0.0-M1 -> 2.0.0-M2 -> 2.0.0-RC1 -> 2.0.0-RC2 -> 2.0.0 -> 2.0.1",
            "1.0.0-RC1 -> 1.0.0-M1 -> 1.0.0-RC2 -> 1.0.0-M2 -> 1.0.0 -> 1.1.0",
          ],
          correct: 3,
          explanation:
            "Doğru sürüm numaralandırma, milestone (M) ve release candidate (RC) aşamalarının mantıklı bir sırayla ilerlemesini gerektirir; D seçeneği bu sırayı doğru yansıtır.",
        },
        {
          question:
            "Aşağıdakilerden hangisi yazılım test stratejileri ile ilgili yanlış bir bilgidir?",
          options: [
            "Geçerleme testlerinde doğru ürünün üretilip üretilmediğine bakılır.",
            "Tümleştirme testinde birimler bir araya getirilerek test edilir.",
            "Beta testleri geliştiricinin kendi ortamında yapılır.",
            "Birim test yönteminde yazılım birimlere ayrılarak test edilir.",
            "Geliştiriciler alfa testlerine dahil olur.",
          ],
          correct: 2,
          explanation:
            "Beta testleri, genellikle geliştiricinin ortamında değil, gerçek kullanıcıların ortamında yapılır.",
        },
        {
          question:
            "Aşağıdaki yazılım geliştirme sonuçlarından hangisi (diğerlerine göre daha çok) performans ve güvenlik gibi kavramlar göz önüne alınarak gerçekleştirilir?",
          options: [
            "Analiz",
            "Tasarım",
            "Unit testler",
            "Bakım",
            "Production ortam",
          ],
          correct: 1,
          explanation:
            "Tasarım aşamasında, performans ve güvenlik gibi unsurlar sistem mimarisine entegre edilir.",
        },
        {
          question:
            "Aşağıdakilerden hangisi çevik (agile) manifestonun prensipleri arasında yer almaz?",
          options: [
            "Bilginin takımlar içerisinde ya da takımlar arasında en iyi paylaşılması ve anlaşılmasının yolu yüz yüze iletişimdir.",
            "Basitlik önemlidir.",
            "En iyi mimari, gereksinimler ve tasarımlar sadece yönetim tarafından organize edilebilen takımlardan çıkar.",
            "İlerlemenin en iyi göstergesi çalışan yazılımdır.",
            "Geliştiriciler ve iş insanları proje boyunca beraber çalışmalıdırlar.",
          ],
          correct: 2,
          explanation:
            "Çevik manifesto, öz-yönetimli takımları teşvik eder; yönetimin tek başına organizasyonu bir çevik prensip değildir.",
        },
        {
          question:
            "Bir yazılım projesinde, ekip değişikliklere hızlı yanıt verebilmeli ve müşteriyle sürekli etkileşim halinde olabilmelidir. Bu özellikler göz önüne alındığında, aşağıdaki süreç modellerinden hangisini tercih etmek uygun olacaktır?",
          options: [
            "V Modeli",
            "Spiral Model",
            "Çevik (Agile) Model",
            "Çift Aşamalı Geliştirme Modeli",
            "Su Çiçeği Modeli",
          ],
          correct: 2,
          explanation:
            "Çevik model, esneklik ve müşteriyle sürekli iletişim gerektiren projeler için idealdir.",
        },
        {
          question:
            "Aşağıdaki yazılım geliştirme sonuçlarından hangisinde (en fazla) performans ve güvenlik gibi kavramlar göz önüne alınarak gerçekleştirilmektedir?",
          options: [
            "Analiz",
            "Tasarım",
            "Unit testler",
            "Bakım",
            "Production ortam",
          ],
          correct: 1,
          explanation:
            "Tasarım aşamasında performans ve güvenlik gibi kritik unsurlar sistemin temel yapısına dahil edilir.",
        },
        {
          question:
            "Hangi test seviyesi, genellikle geliştirme sürecinin erken aşamalarında, yazılım modüllerinin bireysel olarak doğruluğunu kontrol etmek için kullanılır?",
          options: [
            "Sistem Testi",
            "Entegrasyon Testi",
            "Birim Testi",
            "Kabul Testi",
            "Kullanılabilirlik Testi",
          ],
          correct: 2,
          explanation:
            "Birim testi, modüllerin bireysel doğruluğunu erken aşamada kontrol eder.",
        },
        {
          question: "Hangisi çağlayan modelinin avantajlarından değildir?",
          options: [
            "Erken işin miktarını arttırır.",
            "Proje yöneticileri için işin dağılımını yapma açısından kolaydır.",
            "Aşamaları iyi anlaşılabilir.",
            "Gereksinimleri iyi anlaşılabilen projelerde iyi çalışır.",
            "Genelde yazılımın kullanıcıya ulaşma zamanı uzundur.",
          ],
          correct: 4,
          explanation:
            "Yazılımın kullanıcıya geç ulaşması, çağlayan modelinin bir dezavantajıdır, avantajı değildir.",
        },
        {
          question:
            "XP (Extreme Programming) yönteminde Pair Programming uygulamasının amacı nedir?",
          options: [
            "Kod yazma hızını artırmak",
            "Hataları en aza indirmek",
            "Müşteri memnuniyetini artırmak",
            "Sürekli entegrasyonu teşvik etmek",
            "Gereksinimleri daha iyi anlamak",
          ],
          correct: 1,
          explanation:
            "Pair Programming, iki geliştiricinin birlikte çalışarak hata oranını azaltmasını amaçlar.",
        },
        {
          question:
            "Bir çevik projede, ürün sahibi sürekli olarak sprint planı üzerinde değişiklikler yapmaktadır. Bu durum, ekip üzerinde hangi etkiye sahiptir?",
          options: [
            "Ekibin motivasyonunu ve üretkenliğini artırır.",
            "Ekibin moralini ve iş birliğini bozar.",
            "Ekibin planlama ve tahmin yeteneğini geliştirir.",
            "Ekibin çevik değerlerine olan bağlılığını güçlendirir.",
            "Ekibin ürünün kalitesine olan odaklanmasını sağlar.",
          ],
          correct: 1,
          explanation:
            "Sürekli değişiklikler, ekibin planlama yapmasını zorlaştırarak moral ve iş birliğini olumsuz etkiler.",
        },
        {
          question: "Hangisi yazılım geliştirme süreçlerinden biri değildir?",
          options: [
            "Waterfall Model",
            "Extreme Programming",
            "V-shaped Model",
            "Database Model",
            "Spiral Model",
          ],
          correct: 3,
          explanation:
            "Database Model, bir yazılım geliştirme süreci değil, veri yönetimi ile ilgilidir.",
        },
        {
          question:
            "“Bir modüldeki işlemler arasında denetim ilişkisi bulunmaktadır. İşlemlerin birbirleri ile veri ilişkisi yoktur, ancak işlem sırası önemlidir.” Bu modülde hangi yapışıklık türü kullanılmıştır?",
          options: [
            "İşlevsel yapışıklık",
            "Zamansal yapışıklık",
            "Yordamsal yapışıklık",
            "Sırasal yapışıklık",
            "Mantıksal yapışıklık",
          ],
          correct: 2,
          explanation:
            "Yordamsal yapışıklık, işlemlerin sırasının önemli olduğu ancak veri paylaşımının olmadığı durumlarda kullanılır.",
        },
        {
          question:
            "Çevik süreçlerin değişimi hoş karşılamasının nedeni nedir?",
          options: [
            "Geliştiricilerin iş yükünü azaltmak",
            "Müşterinin rekabetçi avantajını artırmak",
            "Projeyi daha hızlı tamamlamak",
            "Geliştiricilerin daha yaratıcı olmasını sağlamak",
            "Maliyetleri düşürmek",
          ],
          correct: 1,
          explanation:
            "Çevik süreçler, değişimi hoş karşılar çünkü bu, müşterinin piyasada avantaj elde etmesini sağlar.",
        },
        {
          question:
            "Aşağıdakilerden hangisi süreç akışı için kullanılan belirtim yöntemlerinden birisidir?",
          options: [
            "Düz Metin",
            "Karar Tabloları",
            "Karar Ağaçları",
            "Nesne-Sınıf Şemaları",
            "Algoritma",
          ],
          correct: 3,
          explanation:
            "Nesne-Sınıf Şemaları, süreç akışını değil, sistemin yapısını tanımlamak için kullanılır; diğerleri süreç akışı belirtim yöntemleridir.",
        },
        {
          question:
            "Aşağıdakilerden hangisi yazılım süreci modellerinden olan barok modeli özellikleri arasında sayılmaz?",
          options: [
            "Yaşam döngüsü temel adımlarının doğrusal bir şekilde geliştirildiği modeldir.",
            "Belgelemeyi işin doğal bir ürünü olarak görmektedir.",
            "Gerçekleştirim aşamasına daha fazla önem verilmiş bir modeldir.",
            "Aşamalar arası geri dönüşlerin nasıl yapılacağı belli değildir.",
            "Çağlayan modele göre geri dönüşler kötü tanımlanmıştır.",
          ],
          correct: 1,
          explanation:
            "Barok model, belgelemeyi doğal bir ürün olarak görmez; bu, daha çok çevik yaklaşımlara özgü bir özelliktir.",
        },
        {
          question: "Hangisi üç programlama özelliği değildir?",
          options: [
            "Takımın bilgisayarları kübiklerle bölünmüş büyük bir odanın ortasında yer alır.",
            "Hiç kimse aynı iş için peşpeşe iki haftadan fazla çalışamaz.",
            "Küçük ve orta ölçekli projelerde kullanılırlar",
            "Parçalar geliştirilmeden önce ayrı büyük bir tasarım aşaması yoktur.",
            "Takım içerisinde özelleşme vardır.",
          ],
          correct: 4,
          explanation:
            "Takım içerisinde özelleşme, çevik yaklaşımlarda değil, daha geleneksel modellerde görülür.",
        },
        {
          question: "Aşağıdakilerden hangisi donanımın bir özelliği değildir?",
          options: [
            "Yeni gereksinimler donanıma ekler yaparak yansıtılır.",
            "Ömrünü tamamladığında değiştirilebilirdir.",
            "Hayati önem taşıdığı için kopyasını barındırır.",
            "Donanım üretilir.",
            "Donanım bileşenleri dışarıdan temin edilebilir.",
          ],
          correct: 0,
          explanation:
            "Yeni gereksinimler donanıma eklerle yansıtılmaz; bu, yazılımın bir özelliğidir.",
        },
        {
          question:
            "Veri tasarımında dikkat edilmesi gereken unsurlardan hangisi yanlıştır?",
          options: [
            "Değişik veri yapıları değerlendirilmelidir.",
            "Veri yapıları üzerinde yapılacak işlemler tanımlanmalıdır.",
            "Alt düzeyde tasarım kararları tasarım süreci içerisinde geciktirilmelidir.",
            "Bazı çok kullanılan veri yapıları için bir kütüphane oluşturulmalıdır.",
            "Kullanılacak programlama dili somut veri tiplerini desteklemeli",
          ],
          correct: 4,
          explanation:
            "Programlama dilinin somut veri tiplerini desteklemesi bir gereklilik değildir; soyut veri tipleri de kullanılabilir.",
        },
        {
          question:
            "Yazılım Geliştirme Yaşam Döngüsü (SDLC) hangi adımı içermez?",
          options: ["Planlama", "Analiz", "Muhasebe", "Gerçekleştirim"],
          correct: 2,
          explanation:
            "Muhasebe, SDLC’nin bir adımı değildir; diğerleri standart aşamalardır.",
        },
        {
          question: "Yazılım Süreci, aşağıdakilerden hangisini ifade eder?",
          options: [
            "Yazılımın kurulumu",
            "Yazılım geliştirme için birbiriyle tutarlı aktivite grubu",
            "Bilgisayar donanımının güncellenmesi",
            "İnternet bağlantısının kurulması",
          ],
          correct: 1,
          explanation:
            "Yazılım süreci, geliştirme için tutarlı aktiviteleri kapsar.",
        },
        {
          question: "Hangi modelin başarısı ilk evrimin başarısına bağımlıdır?",
          options: [
            "Helezonoik model",
            "V model",
            "Çağlayan model",
            "Barok model",
            "Evrimsel geliştirme modeli",
          ],
          correct: 4,
          explanation:
            "Evrimsel geliştirme modeli, ilk evrimin başarısına bağlı olarak ilerler.",
        },
        {
          question:
            "Aşağıdakilerden hangisi yordamsal tasarım ile mimari tasarım arasındaki farklardan biridir?",
          options: [
            "Yordamsal tasarım, diğer modüllere hizmet sağlayan sistem bileşenlerini tanımlar; mimari tasarım ise yazılım modüllerinin iç yapısını tanımlar.",
            "Mimari tasarım, algoritmik ayrıntıları belirler; yordamsal tasarım ise sistem bileşenlerinin genel yapısını tanımlar.",
            "Mimari tasarım, bağımsız bir sistem olarak çalışabilir; yordamsal tasarım ise diğer modüllerin sağladığı hizmetleri kullanır.",
            "Yordamsal tasarım, yazılım modüllerinin iç yapısındaki algoritmik ayrıntıları tanımlar; mimari tasarım ise sistem bileşenlerini ve onların ilişkilerini tanımlar.",
            "Yordamsal tasarım, nesne, program, paket gibi bileşenler içerir; mimari tasarım ise prosedür ve fonksiyonları içerir.",
          ],
          correct: 3,
          explanation:
            "Yordamsal tasarım, algoritmik detayları içerir; mimari tasarım ise sistemin genel yapısını ve ilişkilerini tanımlar.",
        },
        {
          question:
            "Kara kutu testi hakkında aşağıdakilerden hangisi yanlıştır?",
          options: [
            "Kara kutu testi yazılımın arayüzü düzeyinde yapılır.",
            "Amaç yazılımın işlevlerini yerine getirdiğini göstermektir.",
            "Kullanıcı, bu testler sırasında yazılımın içyapısıyla ilgilenir.",
            "Girdi ya da çıktılar çeşitli ortamlarda sağlanan veri ya da bilgi olabileceği gibi bir donanımdan veri alınması veya bir donanıma kumanda edilmesi de olabilir.",
            "Testlerin düzeyi, kullanım alanına göre değişiklik gösterebilir.",
          ],
          correct: 2,
          explanation:
            "Kara kutu testinde kullanıcı, yazılımın iç yapısıyla ilgilenmez; yalnızca giriş ve çıkışlara odaklanır.",
        },
        {
          question:
            "Aşağıdakilerden hangisinde yazılım test türleri ve test stratejileri hakkında verilen bilgilerden hangisi doğrudur?",
          options: [
            "Saydam kutu testi, kullanıcı arayüzüne odaklanır ve iç işleyişi dikkate almaz.",
            "Birim testinde (Unit Test), çok programlı sistemlerde birimlerin ayrı ayrı test edilmesine gerek yoktur.",
            "Kara Kutu testinde, sistem gereksinimlerine dayanarak esas kullanıcıya yönelik test durumları oluşturur.",
            "Alfa testinde, geliştirici genellikle bu testlere katılmaz yalnızca belirli aralıklara sonuçları ve yorumları alır.",
            "Sistem testi, yazılımın diğer donanım ve yazılımlarla nasıl etkileştiğini test eder ve bu testlerden sonra hata bulma ve sistemi deneme amacıyla hazırlık testleri yapılır.",
          ],
          correct: 2,
          explanation:
            "Kara kutu testi, sistem gereksinimlerine dayanarak kullanıcı odaklı testler oluşturur.",
        },
        {
          question: "Çevik Manifesto'ya göre en önemli öncelik nedir?",
          options: [
            "Projeyi hızlıca tamamlamak",
            "Geliştiricilerin memnuniyeti",
            "Müşteriyi değerli yazılımı erken zamanda ve sürekli sunarak memnun etmek",
            "Gereksinimlerin değişmemesi",
            "Geliştirme sürecinde maliyeti düşürmek",
          ],
          correct: 2,
          explanation:
            "Çevik Manifesto’nun temel önceliği, müşteriye erken ve sürekli değer sunmaktır.",
        },
        {
          question: "Spiral modelinin temel amacı nedir?",
          options: [
            "Tekrarlayan geliştirme ile riskleri azaltmak.",
            "Projeyi hızlı bir şekilde tamamlamak.",
            "Müşteri geri bildirimlerine dayalı geliştirme.",
            "Ayrıntılı dokümantasyon oluşturmak.",
            "Proje maliyetlerini minimize etmek.",
          ],
          correct: 0,
          explanation:
            "Spiral model, riskleri azaltmak için tekrarlayan bir yaklaşım benimser.",
        },
        {
          question:
            "Extreme Programming yönteminde çiftler halinde çalışan yazılımcılar hangi faaliyeti birlikte gerçekleştirir?",
          options: [
            "Kodlama ve test etme",
            "Gereksinim analizi",
            "Proje planlaması",
            "Müşteri değerlendirmesi",
            "Yazılım dağıtımı",
          ],
          correct: 0,
          explanation:
            "Çift programlama, kodlama ve test etmeyi birlikte yapmayı içerir.",
        },
        {
          question:
            "Agile süreçlerinde, müşteri memnuniyetini sağlamak için hangi ilke benimsenir?",
          options: [
            "Projenin başında tüm gereksinimlerin sabitlenmesi",
            "Değişen gereksinimlerin kabul edilmesi",
            "Uzun süreli planlamalar yapılması",
            "Müşteri geri bildirimlerinin göz ardı edilmesi",
            "Yalnızca iç süreçlere odaklanılması",
          ],
          correct: 1,
          explanation:
            "Çevik süreçler, değişen gereksinimleri kabul ederek müşteri memnuniyetini hedefler.",
        },
        {
          question:
            "Aşağıdakilerden hangisi Extreme Programming (XP) pratiği değildir?",
          options: [
            "Pair Programming",
            "Continuous Integration",
            "Waterfall Planning",
            "Refactoring",
            "Testing",
          ],
          correct: 2,
          explanation:
            "Waterfall Planning, XP’nin bir pratiği değildir; XP iteratif bir yaklaşımdır.",
        },
        {
          question:
            "Aşağıdaki bakım türlerinden hangisi, yazılımın performansını artırmak, bellek sızıntılarını gidermek ve kod tabanını temizlemek için yapılan bakım türü olarak sınıflandırılabilir?",
          options: [
            "Uyarlayıcı Bakım",
            "Düzeltici Bakım",
            "İyileştirici Bakım",
            "Önleyici Bakım",
            "Kapsamlı Bakım",
          ],
          correct: 3,
          explanation:
            "Önleyici bakım, performans artışı ve kod temizliği gibi proaktif iyileştirmeleri kapsar.",
        },
        {
          question:
            "Bir yazılım projesinde sistem testi aşaması sırasında, aşağıdaki faaliyetlerden hangisi gerçekleştirilmez?",
          options: [
            "Yazılımın tüm fonksiyonlarının doğru çalıştığı doğrulanır.",
            "Yazılımın performansı ölçülür ve gereksinimlere uygun olup olmadığı belirlenir.",
            "Yazılımın kullanıcı arayüzü, kullanılabilirlik ve erişilebilirlik açısından değerlendirilir.",
            "Yazılım kodunun derlenmesi ve hata ayıklama işlemi yapılır.",
            "Tüm sistem testi senaryolarının başarılı bir şekilde tamamlanmasının ardından, yazılımın kullanıcılar tarafından kabul edilip edilmeyeceği belirlenir",
          ],
          correct: 3,
          explanation:
            "Kod derleme ve hata ayıklama, sistem testi değil, geliştirme aşamasında yapılır.",
        },
        {
          question:
            "Yazılım teslim edildikten sonra, kullanıcı, kullanım sırasında karşılaştığı yanlış hesaplama, hatalı davranış, eksik veri gösterimi gibi yazılım kusurlarını bildirerek düzeltilmesini isteyebilir. Bu yazılım bakım türü aşağıdaki hangi bakım türü için en doğru olur?",
          options: [
            "Düzeltici (Corrective) bakım",
            "Uyarlayıcı (Adaptive) bakım",
            "İyileştirici (Perfective) bakım",
            "Önleyici (Preventive) bakım",
            "Geliştirici (Developer) bakım",
          ],
          correct: 0,
          explanation:
            "Düzeltici bakım, mevcut hataları düzeltmek için yapılır.",
        },
        {
          question:
            "Aşağıdakilerden hangisi yazılım süreç modeli olan helezonik modelin avantajlarından biri değildir?",
          options: [
            "Pek çok yazılım modelini içinde bulundurur.",
            "Geliştirmeyi küçük parçalara böler. En riskli kısımlar önce gerçekleştirilir.",
            "Her döngü bir fazı ifade eder. Doğrudan tanımlama, tasarım,... vs gibi bir faz yoktur.",
            "Küçük ve düşük riskli projeler için ucuz bir yöntemdir.",
            "Geliştirmeyi küçük parçalara böler. En riskli kısımlar önce gerçekleştirilir.",
          ],
          correct: 3,
          explanation:
            "Helezonik model, karmaşık ve riskli projeler için uygundur; küçük ve düşük riskli projelerde genellikle maliyet etkin değildir.",
        },
        {
          question:
            "Hangi özellik, Çağlayan Modeli ile Agile Modeller arasındaki farkı en iyi açıklar?",
          options: [
            "Çağlayan Modeli, yazılım geliştirme sürecini tek bir büyük döngüde yönetirken, Agile Modeller birden fazla küçük döngüde çalışır.",
            "Çağlayan Modeli, bireysel geliştiricilerin inisiyatifini teşvik ederken, Agile Modeller daha fazla mikro yönetim sağlar.",
            "Çağlayan Modeli, değişen müşteri gereksinimlerine hızla uyum sağlayabilirken, Agile Modeller daha fazla belgelendirme ve iş süreci standardizasyonu sağlar.",
            "Çağlayan Modeli, yazılım geliştirme sürecini sıkı bir plan ve sıralı adımlarla yönetirken, Agile Modeller daha esnek ve iteratif bir yaklaşım benimser.",
          ],
          correct: 3,
          explanation:
            "Çağlayan modeli sıralı ve katıdır; Agile ise esnek ve iteratiftir.",
        },
        {
          question:
            "Bir hastane için hastaların hayati belirtilerini izleyen bir tıbbi cihaz yazılımı geliştirilmek isteniyor. Bu yazılım için aşağıdaki yazılım süreç modellerinden hangisi uygundur?",
          options: [
            "Gelişigüzel model",
            "Barok Modeli",
            "Çağlayan (Şelale) Modeli",
            "V Süreç Modeli",
            "Artırımlı Geliştirme Süreç Modeli",
          ],
          correct: 3,
          explanation:
            "V Süreç Modeli, kritik sistemlerde doğrulama ve validasyona odaklandığı için uygundur.",
        },
        {
          question:
            "Aşağıdakilerden hangisi çevik (agile) proje geliştirme metodolojisinin dezavantajlarından biri değildir?",
          options: [
            "Ürün gereksinimleri sürekli değişebileceğinden maliyetler önceden tahmin edilemez.",
            "Ekip katılımına öncelik verilerek kurulan iletişim sayesinde sorunların daha hızlı çözülmesini sağlar.",
            "Gerekli olan her aşamada müşteriden geri bildirim almak zor olabilir.",
            "Müşteriler geri bildirim vermek istediklerinde akıllarına gelebilecek yeni istekler ek işleri ortaya çıkarır.",
            "Müşteri ile iletişimi zor olan büyük kurumsal yapılarda uygulamak zordur.",
          ],
          correct: 1,
          explanation:
            "Ekip katılımı ve iletişim, çevik metodolojinin bir avantajıdır, dezavantajı değildir.",
        },
        {
          question:
            "Aşağıdakilerden hangisi extreme programmingde pair working etkinliğini arttırır?",
          options: [
            "Ekip üyelerinin sürekli farklı partnerlerle çalışmasını sağlamak.",
            "Bir partnerin diğerine göre daha çok çalışması.",
            "Partnerlerin birbirleriyle çok sık çatışması.",
            "Bir partnerin diğerine göre daha çok karar alması.",
            "Birbirleriyle anlaşamayan ekip üyelerini eşleştirmek.",
          ],
          correct: 0,
          explanation:
            "Farklı partnerlerle çalışma, bilgi paylaşımını ve etkinliği artırır.",
        },
        {
          question:
            "Aşağıdakilerden hangisi Helezonik Model'in Avantajlarından biri değildir?",
          options: [
            "Risk analizi olgusu ön plandadır.",
            "Prototip yaklaşımı vardır.",
            "Ara adımların fazlalığı nedeniyle dokümantasyon gerektirir.",
            "Kullanıcılar sistemi erken görebilir.",
            "Hataları erken gidermeye odaklanır.",
          ],
          correct: 2,
          explanation:
            "Dokümantasyon gerekliliği, Helezonik Model’in bir dezavantajıdır, avantajı değildir.",
        },
        {
          question: "Aşağıdakilerden hangisi bakım türlerinden değildir?",
          options: [
            "Düzeltici (Corrective)",
            "Uyarlayıcı (Adaptive)",
            "Geliştirici (Enhancive)",
            "İyileştirici (Perfective)",
            "Önleyici (Preventive)",
          ],
          correct: 2,
          explanation:
            "Geliştirici (Enhancive), standart bir bakım türü değildir.",
        },
        {
          question:
            "Aşağıdakilerden hangisi Helezonik Model'in Avantajlarından biri değildir?",
          options: [
            "Risk analizi olgusu ön plandadır.",
            "Prototip yaklaşımı vardır.",
            "Ara adımların fazlalığı nedeniyle dokümantasyon gerektirir.",
            "Kullanıcılar sistemi erken görebilir.",
            "Hataları erken gidermeye odaklanır.",
          ],
          correct: 2,
          explanation:
            "Dokümantasyon gerekliliği, Helezonik Model’in bir dezavantajıdır, avantajı değildir.",
        },
        {
          question: "Aşağıdakilerden hangisi bir yazılım bakım türü değildir?",
          options: [
            "Düzeltici",
            "Uyarlayıcı",
            "Denetleyici",
            "Önleyici",
            "İyileştirici",
          ],
          correct: 2,
          explanation:
            "Denetleyici, bir bakım türü değildir; diğerleri standart bakım türleridir.",
        },
        {
          question:
            "Aşağıdaki projelerden hangisinin Çağlayan (Waterfall) modeli ile yapılması daha olasıdır?",
          options: [
            "Mobil uygulama tasarımı",
            "Yapay zeka algoritma yazılımı tasarımı",
            "Bir e-ticaret web sitesi tasarımı",
            "Bir startup ın yeni bir ürün fikrini test etmek için geliştirdiği prototip tasarımı",
            "MR cihazı için yazılım tasarımı",
          ],
          correct: 4,
          explanation:
            "MR cihazı gibi kritik ve iyi tanımlı gereksinimlere sahip projeler, Çağlayan modeli için uygundur.",
        },
        {
          question:
            "Bir yazılımın 'major' numarasının artırılmasının genellikle hangi durumu temsil ettiği aşağıdakilerden hangisidir?",
          options: [
            "Yeni bir özellik eklenmesi",
            "Bir hata giderilmesi",
            "Köklü değişiklikler ve yeni bir ortama uyarlamalar",
            "Yazılımın general availability (GA) aşamasına geçmesi",
            "Oluşturulan bir prototipin test edilmesi",
          ],
          correct: 2,
          explanation:
            "Major numara, köklü değişiklikleri ve büyük güncellemeleri temsil eder.",
        },
        {
          question:
            "Aşağıdaki ifadelerden hangisi Extreme Programming (XP) metodolojisinin temel ilkeleri ve uygulamaları ile doğru bir şekilde eşleştirilmiştir?",
          options: [
            "Incremental Development - Tüm sistemin tek seferde geliştirilmesi ve ardından test edilmesi",
            "Test-Driven Development (TDD) - Kod yazımı tamamlandıktan sonra testlerin yazılması ve yürütülmesi",
            "Continuous Integration - Kodun belirli aralıklarla entegre edilip büyük sürümlerin yayımlanması",
            "Refactoring - Kodun işlevselliğini değiştirmeden yapısal olarak iyileştirilmesi",
            "Pair Programming - Geliştiricilerin bireysel olarak çalışıp daha sonra kodlarını birleştirmesi",
          ],
          correct: 3,
          explanation:
            "Refactoring, XP’de kodun yapısını iyileştirmeyi ifade eder ve doğru eşleşmedir.",
        },
        {
          question:
            "Aşağıdakilerden hangisi yazılımın temel krizleri arasında gösterilemez?",
          options: [
            "Tasarlanan zamanın gerisinde kalma",
            "Bütçeyi aşma",
            "Güvenilir olmayan yazılım",
            "Bu sektörle ilgilenen kişi sayısının çok olması",
            "Sürekliliğin sağlanmasındaki zorluk",
          ],
          correct: 3,
          explanation:
            "Sektördeki kişi sayısı, yazılım krizlerinden biri değildir; diğerleri yaygın krizlerdir.",
        },
        {
          question:
            "Aşağıda verilen Kara kutu testi ile ilgili maddelerden hangisi yanlıştır?",
          options: [
            "Yazılımın ara yüzü düzeyinde yapılır.",
            "Kullanıcı, bu testler sırasında yazılımın iç yapısıyla ilgilenir.",
            "Amaç yazılımın işlevlerini yerine getirdiğini göstermektir.",
            "Testler hata bulmak için yapılır.",
            "Testlerin düzey, kullanım alanına göre değişiklik gösterebilir.",
          ],
          correct: 1,
          explanation:
            "Kara kutu testinde kullanıcı, iç yapıyla ilgilenmez; sadece giriş-çıkışlar test edilir.",
        },
        {
          question:
            "Aşağıdakilerden hangisi metodolojilerde helezonik modeli ön plana çıkaran özelliklerden sayılmaz?",
          options: [
            "Prototip yaklaşımı",
            "Risk analizi",
            "Evrimsel yaklaşım",
            "Her döngünün bir faza karşılık geldiği yaklaşım",
            "Yinelemeli artırımsal yaklaşım",
          ],
          correct: 2,
          explanation:
            "Evrimsel yaklaşım, helezonik modelin değil, evrimsel geliştirme modelinin özelliğidir.",
        },
      ];
      let currentModel = questionsModel1;
      let currentQuestion = 0;
      let score = 0;
      let answered = Array(50).fill(false);
      let userAnswers = Array(50).fill(null);
      let wrongQuestions = [];
      let isRetrying = false;

      const questionArea = document.getElementById("questionArea");
      const explanationDiv = document.getElementById("explanation");
      const scoreDiv = document.getElementById("score");
      const tableBody = document.getElementById("tableBody");
      const modelSelect = document.getElementById("modelSelect");
      const submitBtn = document.getElementById("submitBtn");
      const overlay = document.getElementById("overlay");
      const popup = document.getElementById("popup");
      const popupScore = document.getElementById("popupScore");
      const retryWrongBtn = document.getElementById("retryWrongBtn");
      const closePopupBtn = document.getElementById("closePopupBtn");

      function displayQuestion() {
        const q = currentModel[currentQuestion];
        questionArea.innerHTML = `
          <p class="text-lg text-gray-800">${currentQuestion + 1}. ${
          q.question
        }</p>
          <ul class="space-y-2 mt-2">
            ${q.options
              .map(
                (opt, i) => `
              <li><label class="flex items-center"><input type="radio" name="answer" value="${i}" ${
                  answered[currentQuestion] ? "disabled" : ""
                } class="mr-2"> ${opt}</label></li>
            `
              )
              .join("")}
          </ul>
        `;
        explanationDiv.classList.add("hidden");
        submitBtn.textContent = answered[currentQuestion]
          ? "Next"
          : "Submit Answer";
        if (
          answered[currentQuestion] &&
          userAnswers[currentQuestion] !== null
        ) {
          showExplanation();
        }
      }

      function updateScore() {
        scoreDiv.textContent = `Score: ${score}/${currentModel.length}`;
      }

      function updateTable() {
        tableBody.innerHTML = currentModel
          .map((_, i) => {
            const status = answered[i]
              ? userAnswers[i] === currentModel[i].correct
                ? "Correct"
                : "Incorrect"
              : "Not Answered";
            const className = answered[i]
              ? userAnswers[i] === currentModel[i].correct
                ? "correct"
                : "incorrect"
              : "";
            return `
            <tr class="${i % 2 === 0 ? "bg-gray-50" : "bg-white"}">
              <td class="border p-2">${i + 1}</td>
              <td class="border p-2 ${className}">${status}</td>
            </tr>`;
          })
          .join("");
      }

      function showExplanation() {
        const q = currentModel[currentQuestion];
        const userAnswer = userAnswers[currentQuestion];
        explanationDiv.classList.remove("hidden");
        if (userAnswer === q.correct) {
          explanationDiv.innerHTML = `<p class="correct">Correct! ${q.explanation}</p>`;
        } else {
          explanationDiv.innerHTML = `<p class="incorrect">Wrong! Correct answer: ${
            q.options[q.correct]
          }. ${q.explanation}</p>`;
        }
      }

      function submitAnswer() {
        if (answered[currentQuestion]) {
          goToNextQuestion();
          return;
        }
        const selected = document.querySelector('input[name="answer"]:checked');
        if (!selected) {
          alert("Please select an answer!");
          return;
        }
        const answer = parseInt(selected.value);
        userAnswers[currentQuestion] = answer;
        answered[currentQuestion] = true;
        if (answer === currentModel[currentQuestion].correct) {
          score++;
        } else {
          wrongQuestions.push(currentQuestion);
        }
        showExplanation();
        updateScore();
        updateTable();
        document
          .querySelectorAll('input[name="answer"]')
          .forEach((input) => (input.disabled = true));
        submitBtn.textContent = "Next";
      }

      function goToNextQuestion() {
        currentQuestion++;
        if (currentQuestion >= currentModel.length) {
          showScorePopup();
        } else {
          displayQuestion();
        }
      }

      function showScorePopup() {
        overlay.style.display = "block";
        popup.style.display = "block";
        popupScore.textContent = `Your score: ${score}/${currentModel.length}`;
        retryWrongBtn.style.display =
          wrongQuestions.length > 0 ? "inline-block" : "none";
      }

      function resetQuiz() {
        currentQuestion = 0;
        score = 0;
        answered.fill(false);
        userAnswers.fill(null);
        wrongQuestions = [];
        isRetrying = false;

        if (modelSelect.value === "model1") currentModel = questionsModel1;
        else if (modelSelect.value === "model2") currentModel = questionsModel2;
        else if (modelSelect.value === "model3") currentModel = questionsModel3;
        else if (modelSelect.value === "model4") currentModel = questionsModel4;
        else if (modelSelect.value === "model5") currentModel = questionsModel5;
        else if (modelSelect.value === "model6") currentModel = questionsModel6;
        else if (modelSelect.value === "model7") currentModel = questionsModel7;

        displayQuestion();
        updateScore();
        updateTable();
        overlay.style.display = "none";
        popup.style.display = "none";
      }

      function randomizeQuestions() {
        for (let i = currentModel.length - 1; i > 0; i--) {
          const j = Math.floor(Math.random() * (i + 1));
          [currentModel[i], currentModel[j]] = [
            currentModel[j],
            currentModel[i],
          ];
        }
        resetQuiz();
      }

      function switchModel() {
        resetQuiz();
      }

      function retryWrongQuestions() {
        if (wrongQuestions.length === 0) return;
        const wrongIndices = [...wrongQuestions];
        currentModel = wrongIndices.map((i) => currentModel[i]);
        currentQuestion = 0;
        score = 0;
        answered = Array(currentModel.length).fill(false);
        userAnswers = Array(currentModel.length).fill(null);
        wrongQuestions = [];
        isRetrying = true;
        displayQuestion();
        updateScore();
        updateTable();
        overlay.style.display = "none";
        popup.style.display = "none";
      }

      submitBtn.addEventListener("click", submitAnswer);
      document.getElementById("resetBtn").addEventListener("click", resetQuiz);
      document
        .getElementById("randomBtn")
        .addEventListener("click", randomizeQuestions);
      modelSelect.addEventListener("change", switchModel);
      retryWrongBtn.addEventListener("click", retryWrongQuestions);
      closePopupBtn.addEventListener("click", () => {
        overlay.style.display = "none";
        popup.style.display = "none";
      });

      displayQuestion();
      updateScore();
      updateTable();
    </script>
  </body>
</html>
