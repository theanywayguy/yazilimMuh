<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Yazılım Mühendisliği Quiz</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
      .correct {
        color: #10b981;
      }
      .incorrect {
        color: #ef4444;
      }
      .popup {
        display: none;
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background: white;
        padding: 2rem;
        border-radius: 0.5rem;
        box-shadow: 0 10px 15px rgba(0, 0, 0, 0.2);
        z-index: 50;
      }
      .overlay {
        display: none;
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.5);
        z-index: 40;
      }
    </style>
  </head>
  <body class="bg-gray-100 font-sans">
    <div class="max-w-4xl mx-auto p-6">
      <h1 class="text-3xl font-bold text-center text-gray-800 mb-6">
        Yazılım Mühendisliği Quiz
      </h1>
      <div class="bg-white p-6 rounded-lg shadow-lg">
        <div class="flex justify-center mb-4">
          <label for="modelSelect" class="mr-2 text-lg text-gray-700"
            >Select Quiz Model:</label
          >
          <select id="modelSelect" class="p-2 border rounded-lg">
            <option value="model7">MODEL 7</option>
            <option value="model8">MODEL 8</option>
            <option value="pdf7&8">PDF 7 AND 8</option>
            <option value="pdf9">PDF 9</option>
            <option value="pdf10">PDF 10</option>
          </select>
        </div>
        <div id="score" class="text-lg text-gray-700 mb-4">Score: 0/50</div>
        <div id="questionArea" class="mb-6"></div>
        <div id="explanation" class="p-4 border rounded-lg hidden"></div>
        <div class="flex justify-center space-x-4 mt-4">
          <button
            id="submitBtn"
            class="bg-blue-600 text-white px-6 py-2 rounded-lg hover:bg-blue-700 transition"
          >
            Submit Answer
          </button>
          <button
            id="resetBtn"
            class="bg-red-600 text-white px-6 py-2 rounded-lg hover:bg-red-700 transition"
          >
            Reset Quiz
          </button>
          <button
            id="randomBtn"
            class="bg-green-600 text-white px-6 py-2 rounded-lg hover:bg-green-700 transition"
          >
            Randomize Questions
          </button>
        </div>
        <table class="w-full mt-6 border-collapse">
          <thead>
            <tr class="bg-green-600 text-white">
              <th class="border p-2">Question #</th>
              <th class="border p-2">Status</th>
            </tr>
          </thead>
          <tbody id="tableBody" class="text-gray-700"></tbody>
        </table>
      </div>
    </div>
    <div id="overlay" class="overlay"></div>
    <div id="popup" class="popup">
      <h2 class="text-2xl font-bold text-gray-800 mb-4">Quiz Completed!</h2>
      <p id="popupScore" class="text-lg mb-4"></p>
      <button
        id="retryWrongBtn"
        class="bg-blue-600 text-white px-4 py-2 rounded-lg hover:bg-blue-700 transition"
      >
        Retry Wrong Questions
      </button>
      <button
        id="closePopupBtn"
        class="bg-gray-600 text-white px-4 py-2 rounded-lg hover:bg-gray-700 transition ml-2"
      >
        Close
      </button>
    </div>

    <script>
      const pdf7_8 = [
        {
          question:
            "Yazılım geliştirme yaşam döngüsü (SDLC) ile ilgili aşağıdaki ifadelerden hangisi doğrudur?",
          options: [
            "Yazılımın yalnızca üretim aşamasını kapsar.",
            "Doğrusal ve tek yönlü bir süreçtir.",
            "Gereksinimlerin sürekli değiştiği döngüsel bir süreçtir.",
            "Yazılımın yalnızca bakım aşamasını içerir.",
            "Süreç modellerinden bağımsızdır.",
          ],
          correct: 2,
          explanation:
            "Yazılım geliştirme yaşam döngüsü, yazılımın üretim ve kullanım süreci boyunca geçtiği tüm aşamaları kapsar ve gereksinimlerin değişmesi nedeniyle döngüsel bir süreçtir.",
        },
        {
          question: "Yazılım süreci nedir?",
          options: [
            "Yazılımın yalnızca kodlama aşamasını tanımlar.",
            "Bir yazılım ürününü üretmeyi sağlayan tutarlı aktiviteler grubudur.",
            "Donanım gereksinimlerini belirleme sürecidir.",
            "Yazılımın test edilmesini sağlayan bir yöntemdir.",
            "Yazılımın yalnızca belgeleme aşamasını içerir.",
          ],
          correct: 1,
          explanation:
            "Yazılım süreci, bir yazılım ürününü üretmek için gerekli olan birbirine tutarlı aktiviteleri içerir ve detaylara girmeden ne yapılacağını tanımlar.",
        },
        {
          question:
            "Yazılım yaşam döngüsünün temel adımlarından hangisi personel ve donanım gereksinimlerinin çıkarıldığı aşamadır?",
          options: ["Analiz", "Tasarım", "Planlama", "Gerçekleştirim", "Bakım"],
          correct: 2,
          explanation:
            "Planlama aşaması, personel ve donanım gereksinimlerinin çıkarıldığı, fizibilite çalışmasının yapıldığı ve proje planının oluşturulduğu aşamadır.",
        },
        {
          question:
            "Aşağıdakilerden hangisi yazılım yaşam döngüsünün temel adımları arasında yer almaz?",
          options: ["Planlama", "Analiz", "Tasarım", "Prototipleme", "Bakım"],
          correct: 3,
          explanation:
            "Prototipleme, bazı süreç modellerinde kullanılan bir yöntemdir ancak yazılım yaşam döngüsünün temel adımları arasında yer almaz; temel adımlar planlama, analiz, tasarım, gerçekleştirim ve bakımdır.",
        },
        {
          question:
            "Yazılım geçerleme (validation) sürecinin temel amacı nedir?",
          options: [
            "Yazılımın donanım gereksinimlerini belirlemek",
            "Sistemin müşteri gereksinimlerini karşıladığını doğrulamak",
            "Yazılımın kod satır sayısını ölçmek",
            "Sistemin yalnızca teknik tasarımını oluşturmak",
            "Veritabanı yapılarını tanımlamak",
          ],
          correct: 1,
          explanation:
            "Geçerleme (validation), sistemin müşteri gereksinimlerini karşıladığını doğrulamak için yapılan bir süreçtir.",
        },
        {
          question:
            "Aşağıdakilerden hangisi yazılım süreç modellerinin temel bir özelliği değildir?",
          options: [
            "Süreçlerin düzenli bir şekilde işlemesini sağlar.",
            "Karmaşıklığı azaltır ve kaosu önler.",
            "Yazılımın yalnızca bakım aşamasını kapsar.",
            "Ürünün kalitesini etkileyebilir.",
            "Yöneticilere ve geliştiricilere rehberlik eder.",
          ],
          correct: 2,
          explanation:
            "Yazılım süreç modelleri, yalnızca bakım aşamasını değil, tüm yaşam döngüsünü kapsar ve karmaşıklığı azaltarak rehberlik sağlar.",
        },
        {
          question: "Gelişigüzel Modelin en belirgin özelliği nedir?",
          options: [
            "Belgelemenin ayrı bir süreç olarak ele alınması",
            "Herhangi bir model veya yöntemin olmaması",
            "Yazılımın yalnızca test aşamasına odaklanması",
            "Risk analizine dayalı bir yaklaşım benimsemesi",
            "Kullanıcı geri bildirimlerinin sürekli alınması",
          ],
          correct: 1,
          explanation:
            "Gelişigüzel Model, herhangi bir tanımlı model veya yönteme sahip değildir ve genellikle tek kişilik basit projelerde kullanılır.",
        },
        {
          question:
            "Barok Modeli ile ilgili aşağıdaki ifadelerden hangisi doğrudur?",
          options: [
            "Belgeleme, üretimin doğal bir parçasıdır.",
            "Aşamalar arası geri dönüşler iyi tanımlanmıştır.",
            "Günümüzde kullanımı yaygın olarak önerilir.",
            "Gerçekleştirim aşamasına daha fazla ağırlık verir.",
            "Kullanıcıların sürece erken katılımını teşvik eder.",
          ],
          correct: 3,
          explanation:
            "Barok Modeli, gerçekleştirim aşamasına ağırlık verir ancak günümüzde kullanımı önerilmez ve belgeleme ayrı bir süreç olarak ele alınır.",
        },
        {
          question:
            "Çağlayan (Waterfall) Modeli hangi tür projeler için uygundur?",
          options: [
            "Gereksinimlerin belirsiz olduğu projeler",
            "Yüksek riskli ve karmaşık projeler",
            "Gereksinimlerin iyi tanımlı olduğu ve kısa sürede tamamlanacak projeler",
            "Sürekli müşteri geri bildirimi gerektiren projeler",
            "Prototip odaklı projeler",
          ],
          correct: 2,
          explanation:
            "Çağlayan Modeli, gereksinimlerin iyi tanımlı olduğu ve kısa sürede tamamlanabilecek projeler için uygundur.",
        },
        {
          question:
            "Çağlayan Modelinin bir avantajı aşağıdakilerden hangisidir?",
          options: [
            "Gereksinim değişikliklerine kolayca uyum sağlar.",
            "Müşteriler sistemi erken görebilir.",
            "Proje yöneticileri için iş dağılımını kolaylaştırır.",
            "Risk analizine odaklanır.",
            "Sürekli yinelemeler içerir.",
          ],
          correct: 2,
          explanation:
            "Çağlayan Modeli, iyi tanımlanmış aşamalarıyla proje yöneticileri için iş dağılımını kolaylaştırır.",
        },
        {
          question: "Çağlayan Modelinin bir dezavantajı nedir?",
          options: [
            "Belgeleme süreci ayrı bir aşama olarak ele alınır.",
            "Yazılımın kullanıcıya ulaşma süresi genellikle uzundur.",
            "Risk analizine odaklanır.",
            "Kullanıcıların sürece erken katılımını sağlar.",
            "Gereksinimlerin baştan tam tanımlanmasını gerektirmez.",
          ],
          correct: 1,
          explanation:
            "Çağlayan Modelinde yazılımın kullanıcıya ulaşma süresi uzundur, çünkü tüm aşamalar sırayla tamamlanır.",
        },
        {
          question: "V Süreç Modeli hangi tür projeler için uygundur?",
          options: [
            "Belirsizliklerin yüksek olduğu projeler",
            "Kullanıcı gereksinimlerinin sürekli değiştiği projeler",
            "İş tanımlarının belirgin olduğu BT projeleri",
            "Küçük ölçekli ve prototip odaklı projeler",
            "Yüksek riskli savunma sanayi projeleri",
          ],
          correct: 2,
          explanation:
            "V Süreç Modeli, belirsizliklerin az olduğu ve iş tanımlarının belirgin olduğu BT projeleri için uygundur.",
        },
        {
          question:
            "V Süreç Modelinin temel çıktılarından biri aşağıdakilerden hangisidir?",
          options: [
            "Yazılımın donanım gereksinimleri",
            "Kullanıcı Modeli",
            "Veritabanı şemaları",
            "Proje bütçesi",
            "Risk analiz raporu",
          ],
          correct: 1,
          explanation:
            "V Süreç Modeli, kullanıcı modeli gibi çıktılar üretir ve sistemin kullanıcıyla ilişkilerini tanımlar.",
        },
        {
          question:
            "Helezonik (Spiral) Modelin temel adımlarından biri değildir?",
          options: [
            "Planlama",
            "Risk Analizi",
            "Üretim",
            "Kullanıcı Değerlendirmesi",
            "Kodlama",
          ],
          correct: 4,
          explanation:
            "Helezonik Modelin temel adımları planlama, risk analizi, üretim ve kullanıcı değerlendirmesidir; kodlama, üretim aşamasının bir parçasıdır.",
        },
        {
          question: "Helezonik Modelin en önemli avantajlarından biri nedir?",
          options: [
            "Belgelemenin ayrı bir süreç olarak ele alınması",
            "Kullanıcıların sürece erken katılımını teşvik etmesi",
            "Projenin tek bir döngüde tamamlanması",
            "Gereksinimlerin baştan kesin olarak belirlenmesi",
            "Kodlamanın tüm süreçten sonra başlaması",
          ],
          correct: 1,
          explanation:
            "Helezonik Model, kullanıcıların sürece erken katılımını teşvik ederek riskleri azaltır.",
        },
        {
          question:
            "Helezonik Modelin bir dezavantajı aşağıdakilerden hangisidir?",
          options: [
            "Küçük ve düşük riskli projeler için pahalı olması",
            "Kullanıcıların sürece katılımını engellemesi",
            "Gereksinimlerin baştan tam tanımlanmasını gerektirmesi",
            "Projenin tek bir döngüde tamamlanması",
            "Belgeleme gerektirmemesi",
          ],
          correct: 0,
          explanation:
            "Helezonik Model, küçük ve düşük riskli projeler için pahalı ve karmaşıktır.",
        },
        {
          question:
            "Evrimsel Geliştirme Modeli hangi tür organizasyonlar için uygundur?",
          options: [
            "Küçük ölçekli tek kişilik projeler",
            "Coğrafik olarak geniş alana yayılmış çok birimli organizasyonlar",
            "Gereksinimlerin sürekli değiştiği projeler",
            "Yüksek riskli savunma sanayi projeleri",
            "Kısa sürede tamamlanması gereken projeler",
          ],
          correct: 1,
          explanation:
            "Evrimsel Geliştirme Modeli, coğrafik olarak geniş alana yayılmış çok birimli organizasyonlar (örn. banka uygulamaları) için önerilir.",
        },
        {
          question: "Evrimsel Geliştirme Modelinin başarısı neye bağlıdır?",
          options: [
            "Projenin bütçesine",
            "İlk evrimin başarısına",
            "Kullanıcıların sürece erken katılımına",
            "Belgeleme sürecine",
            "Donanım gereksinimlerine",
          ],
          correct: 1,
          explanation:
            "Evrimsel Geliştirme Modelinin başarısı, ilk evrimin başarısına bağlıdır, çünkü bu model pilot uygulamalara dayanır.",
        },
        {
          question:
            "Artırmsal Geliştirme Modelinde aşağıdakilerden hangisi yapılır?",
          options: [
            "Sistem tek bir parça olarak teslim edilir.",
            "Gereksinimler sürekli değiştirilir.",
            "Yüksek öncelikli gereksinimler ilk artırımlarda gerçekleştirilir.",
            "Proje yalnızca bir döngüde tamamlanır.",
            "Kullanıcılar sürece katılmaz.",
          ],
          correct: 2,
          explanation:
            "Artırmsal Geliştirme Modelinde, yüksek öncelikli gereksinimler ilk artırımlarda gerçekleştirilir ve sistem artırımlara bölünür.",
        },
        {
          question: "Artırmsal Geliştirme Modelinin bir avantajı nedir?",
          options: [
            "Tüm projenin başarısız olma riskini artırır.",
            "En önemli sistem özelliklerinin daha fazla test edilmesini sağlar.",
            "Gereksinimlerin baştan tam tanımlanmasını gerektirmez.",
            "Projenin yalnızca kodlama aşamasına odaklanır.",
            "Kullanıcıların sürece katılımını engeller.",
          ],
          correct: 1,
          explanation:
            "Artırmsal Geliştirme Modeli, en önemli sistem özelliklerinin daha fazla test edilmesini sağlar, böylece risk azalır.",
        },
        {
          question: "Artırmsal Geliştirme Modelinin bir dezavantajı nedir?",
          options: [
            "Deneyimli personel gerektirir.",
            "Sistemin erken teslimini engeller.",
            "Kullanıcıların sürece erken katılımını sağlar.",
            "Projenin tek bir döngüde tamamlanmasını gerektirir.",
            "Belgeleme gerektirmez.",
          ],
          correct: 0,
          explanation:
            "Artırmsal Geliştirme Modeli, deneyimli personel gerektirir, çünkü artırımların doğru tanımlanması zordur.",
        },
        {
          question:
            "Araştırma Tabanlı Süreç Modeli hangi tür projeler için uygundur?",
          options: [
            "Gereksinimlerin iyi tanımlı olduğu projeler",
            "Sabit fiyat sözleşmeli projeler",
            "Belirsizlik üzerine çalışan araştırma ortamları",
            "Küçük ölçekli mobil uygulamalar",
            "Kullanıcı odaklı projeler",
          ],
          correct: 2,
          explanation:
            "Araştırma Tabanlı Model, belirsizlik üzerine çalışan ve genellikle sınırlı kullanım için geliştirilen yazılımlar için uygundur.",
        },
        {
          question: "Çevik (Agile) yöntemlerin temel amacı nedir?",
          options: [
            "Ayrıntılı dokümantasyonu önceliklendirmek",
            "Müşteriyi erken ve sürekli yazılım teslimiyle memnun etmek",
            "Sözleşme görüşmelerine odaklanmak",
            "Süreç ve araçları bireylerden üstün tutmak",
            "Değişimlere direnç göstermek",
          ],
          correct: 1,
          explanation:
            "Çevik yöntemler, müşteriyi erken ve sürekli yazılım teslimiyle memnun etmeyi amaçlar, bu Çevik Manifesto’nun temel prensiplerinden biridir.",
        },
        {
          question:
            "Çevik Manifesto’ya göre aşağıdakilerden hangisi daha fazla değer görür?",
          options: [
            "Süreçler ve araçlar",
            "Kapsamlı dokümantasyon",
            "Bireyler ve etkileşimler",
            "Sözleşme görüşmeleri",
            "Planı takip etmek",
          ],
          correct: 2,
          explanation:
            "Çevik Manifesto, bireyler ve etkileşimleri süreçler ve araçlara göre daha fazla değerli görür.",
        },
        {
          question:
            "Uç Programlama (Extreme Programming) ile ilgili aşağıdakilerden hangisi doğrudur?",
          options: [
            "Büyük ölçekli projeler için uygundur.",
            "Kullanıcı gereksinimlerinin sabit olması gerekir.",
            "Yazılımcılar çiftler halinde çalışır ve test odaklı geliştirme yapar.",
            "Belgeleme ayrı bir süreç olarak ele alınır.",
            "Proje yöneticileri sürece katılmaz.",
          ],
          correct: 2,
          explanation:
            "Uç Programlama, yazılımcıların çiftler halinde çalıştığı ve test odaklı geliştirmeyi teşvik eden bir çevik yöntemdir.",
        },
        {
          question:
            "Uç Programlama (XP) değerlerinden biri aşağıdakilerden hangisidir?",
          options: [
            "Kapsamlı dokümantasyon",
            "İletişim",
            "Sözleşme odaklılık",
            "Doğrusal süreç yönetimi",
            "Risk analizi",
          ],
          correct: 1,
          explanation:
            "Uç Programlama değerleri arasında iletişim, sadeleşme, geri bildirim ve cesaret yer alır.",
        },
        {
          question: "Uç Programlama’da uygulanan 12 pratikten biri değildir?",
          options: [
            "Planlama Oyunu",
            "Küçük Sürümler",
            "Test Odaklı Geliştirme",
            "Risk Analizi",
            "Sürekli Entegrasyon",
          ],
          correct: 3,
          explanation:
            "Uç Programlama’nın 12 pratiği arasında risk analizi yer almaz; bu, Helezonik Modelin bir özelliğidir.",
        },
        {
          question:
            "Scrum sürecinde aşağıdakilerden hangisi bir terim değildir?",
          options: [
            "Ürün Sahibi (Product Owner)",
            "Scrum Master",
            "Sprint Geri Bildirim Tablosu",
            "Ürün Birikimi (Product Backlog)",
            "Sprint Birikimi (Sprint Backlog)",
          ],
          correct: 2,
          explanation:
            "Scrum’da ‘Sprint Geri Bildirim Tablosu’ diye bir terim yoktur; doğru terim ‘Sprint Burn Down Chart’tır.",
        },
        {
          question:
            "Yazılım süreç modeli seçiminde hangi kriter dikkate alınmaz?",
          options: [
            "Modelin riskleri tolere etme kapasitesi",
            "Gereksinim değişikliklerinin sıklığı",
            "Projenin karmaşıklığı",
            "Kullanıcıların programlama dili tercihi",
            "Kurumun yönetimsel kapasitesi",
          ],
          correct: 3,
          explanation:
            "Süreç modeli seçiminde kullanıcıların programlama dili tercihi bir kriter değildir; diğer faktörler doğrudan model seçimini etkiler.",
        },
        {
          question:
            "Aşağıdaki durumlardan hangisinde Çağlayan Modeli yerine Helezonik Model tercih edilmelidir?",
          options: [
            "Gereksinimlerin net ve sabit olduğu bir proje",
            "Küçük ölçekli ve kısa sürede tamamlanacak bir proje",
            "Yüksek riskli ve müşteri geri bildirimine dayalı bir proje",
            "Belgelemenin ayrı bir süreç olarak ele alındığı bir proje",
            "Tek kişilik bir proje",
          ],
          correct: 2,
          explanation:
            "Helezonik Model, yüksek riskli ve müşteri geri bildirimine dayalı projeler için uygundur, Çağlayan Modeli ise net gereksinimlere sahip projeler için daha uygundur.",
        },
        {
          question: "Süreç mimarının temel görevi nedir?",
          options: [
            "Yazılımın kodlamasını yapmak",
            "Proje için en uygun süreç modelini seçmek",
            "Donanım gereksinimlerini belirlemek",
            "Yazılımın yalnızca test aşamasını yönetmek",
            "Müşteriyle sözleşme görüşmeleri yapmak",
          ],
          correct: 1,
          explanation:
            "Süreç mimarı, proje için en uygun süreç modelini seçmekle görevlidir ve modellerin güçlü/zayıf yönlerini değerlendirir.",
        },
      ];

      const pdf10 = [
        {
          question: "Yazılım metrikleri neden değerlidir?",
          options: [
            "Yazılımın yalnızca kodlama süresini ölçer.",
            "Planlama, organizasyon ve kontrol gibi yönetim işlevlerini destekler.",
            "Donanım gereksinimlerini belirler.",
            "Yazılımın yalnızca bakım maliyetini hesaplar.",
            "Kullanıcı arayüzünü tasarlar.",
          ],
          correct: 1,
          explanation:
            "Yazılım metrikleri, ölçülebilir veriler sağlayarak planlama, organizasyon, kontrol ve iyileştirme gibi yönetim işlevlerini destekler.",
        },
        {
          question: "Yazılım metrikleri hangi kategorilere ayrılır?",
          options: [
            "Statik ve Dinamik Metrikler",
            "Ürün ve Süreç Metrikleri",
            "Tasarım ve Kod Metrikleri",
            "Yazılım ve Donanım Metrikleri",
            "Kullanıcı ve Geliştirici Metrikleri",
          ],
          correct: 1,
          explanation:
            "Yazılım metrikleri, ürün metrikleri (ürünün özelliklerini ölçer) ve süreç metrikleri (geliştirme sürecini ölçer) olarak sınıflandırılır.",
        },
        {
          question: "Statik metrikler aşağıdakilerden hangisini içerir?",
          options: [
            "Çalışma zamanı performansı",
            "Tasarım metrikleri",
            "Kullanıcı etkileşimleri",
            "Sistem çalışma süresi",
            "Dinamik bellek kullanımı",
          ],
          correct: 1,
          explanation:
            "Statik metrikler, kodun veya tasarımın statik özelliklerini ölçer ve tasarım metriklerini içerir.",
        },
        {
          question:
            "Yazılım metriklerinin avantajlarından biri aşağıdakilerden hangisidir?",
          options: [
            "Her zaman düşük maliyetlidir.",
            "Farklı programlama dillerinin özelliklerini karşılaştırmayı sağlar.",
            "Yazılımın yalnızca test aşamasını ölçer.",
            "Kullanıcı gereksinimlerini belirler.",
            "Donanım uyumluluğunu garanti eder.",
          ],
          correct: 1,
          explanation:
            "Yazılım metrikleri, farklı programlama dillerinin özelliklerini analiz etmek ve karşılaştırmak için kullanılabilir.",
        },
        {
          question: "Yazılım metriklerinin bir dezavantajı nedir?",
          options: [
            "Uygulaması her zaman kolaydır.",
            "Geçmiş verilere dayalı doğrulaması zor olabilir.",
            "Yazılım kalitesini artırmaz.",
            "Süreç yönetimini desteklemez.",
            "Kullanıcı odaklıdır.",
          ],
          correct: 1,
          explanation:
            "Yazılım metriklerinin doğrulanması, geçmiş veya ampirik verilere dayandığından zor ve maliyetli olabilir.",
        },
        {
          question: "LOC (Lines of Code) metrikleri ne için kullanılır?",
          options: [
            "Yazılımın işlevselliğini ölçmek",
            "Programcı verimliliğini hesaplamak",
            "Kullanıcı arayüzünü değerlendirmek",
            "Donanım gereksinimlerini belirlemek",
            "Veritabanı tasarımını analiz etmek",
          ],
          correct: 1,
          explanation:
            "LOC metrikleri, programcıların verimliliğini ve ürün boyutunu ölçmek için kullanılır.",
        },
        {
          question: "LOC metriklerinin bir avantajı nedir?",
          options: [
            "Dil bağımsızdır.",
            "Kullanıcılar tarafından kolayca anlaşılır.",
            "Ölçmesi kolaydır.",
            "Fonksiyonelliği tam olarak ölçer.",
            "Tasarım kalitesini değerlendirir.",
          ],
          correct: 2,
          explanation:
            "LOC metrikleri, kod satır sayısını ölçmek için basit ve kolay bir yöntemdir.",
        },
        {
          question:
            "LOC metriklerinin bir dezavantajı aşağıdakilerden hangisidir?",
          options: [
            "Kodun uzunluğunu ölçer.",
            "Dil bağımlıdır.",
            "Kolayca ölçülebilir.",
            "Verimliliği artırır.",
            "Kullanıcı odaklıdır.",
          ],
          correct: 1,
          explanation:
            "LOC metrikleri, programlama diline bağlıdır ve bu nedenle farklı dillerde karşılaştırma yapmak zor olabilir.",
        },
        {
          question: "Aşağıdakilerden hangisi LOC metrikleriyle hesaplanabilir?",
          options: [
            "Kullanıcı memnuniyeti",
            "Hata oranı (Errors/KLOC)",
            "Donanım performansı",
            "Veritabanı boyutu",
            "Arayüz tasarımı",
          ],
          correct: 1,
          explanation:
            "LOC metrikleri, hata oranı gibi ölçümleri (Errors/KLOC) hesaplamak için kullanılabilir.",
        },
        {
          question: "Halstead metrikleri hangi özelliği ölçer?",
          options: [
            "Yazılımın işlevsel boyutunu",
            "Programın kelime dağarcığını ve uzunluğunu",
            "Kullanıcı etkileşimlerini",
            "Donanım uyumluluğunu",
            "Veritabanı karmaşıklığını",
          ],
          correct: 1,
          explanation:
            "Halstead metrikleri, programın kelime dağarcığını (n) ve uzunluğunu (N) ölçer.",
        },
        {
          question: "Halstead metriklerinde ‘n’ neyi ifade eder?",
          options: [
            "Program uzunluğu",
            "Kelime dağarcığı",
            "Hata oranı",
            "Çaba seviyesi",
            "Test süresi",
          ],
          correct: 1,
          explanation:
            "Halstead metriklerinde ‘n’, programın kelime dağarcığını (operatör ve operand sayısı) ifade eder.",
        },
        {
          question:
            "Halstead metriklerinde program seviyesi (L) nasıl hesaplanır?",
          options: [
            "L = V / V*",
            "L = V* / V",
            "L = N / n",
            "L = E / T",
            "L = V / N",
          ],
          correct: 1,
          explanation:
            "Program seviyesi (L), potansiyel minimum hacim (V*) ile hacim (V) oranına eşittir: L = V* / V.",
        },
        {
          question:
            "Fonksiyonel Nokta Analizi (FPA) kim tarafından geliştirilmiştir?",
          options: [
            "Barry Boehm",
            "Allan J. Albrecht",
            "Tom DeMarco",
            "Maurice Halstead",
            "Victor Basili",
          ],
          correct: 1,
          explanation:
            "FPA, 1979’da Allan J. Albrecht tarafından IBM’de geliştirilmiştir.",
        },
        {
          question: "Fonksiyonel Nokta Analizi’nin temel amacı nedir?",
          options: [
            "Yazılımın kod satır sayısını ölçmek",
            "Yazılımın işlevsel boyutunu ölçmek",
            "Donanım gereksinimlerini belirlemek",
            "Kullanıcı arayüzünü değerlendirmek",
            "Veritabanı performansını analiz etmek",
          ],
          correct: 1,
          explanation:
            "FPA, yazılımın işlevsel boyutunu ölçerek proje tahminleri yapmak için kullanılır.",
        },
        {
          question:
            "Fonksiyonel Nokta Analizi’nde aşağıdakilerden hangisi bir ölçüm parametresidir?",
          options: [
            "Kod satır sayısı",
            "Kullanıcı girişleri (EI)",
            "Donanım hızı",
            "Veritabanı boyutu",
            "Arayüz renkleri",
          ],
          correct: 1,
          explanation:
            "FPA, kullanıcı girişleri (EI), çıkışlar, sorgular, dosyalar ve arayüzler gibi parametreleri ölçer.",
        },
        {
          question: "FPA ile LOC arasındaki temel fark nedir?",
          options: [
            "FPA dil bağımlıdır, LOC dil bağımsızdır.",
            "FPA kullanıcı odaklıdır, LOC tasarım odaklıdır.",
            "FPA kod satır sayısına dayanır, LOC işlevselliğe dayanır.",
            "FPA yalnızca test için kullanılır, LOC tasarım için kullanılır.",
            "FPA ve LOC aynı ölçütleri kullanır.",
          ],
          correct: 1,
          explanation:
            "FPA, kullanıcı odaklı ve işlevselliğe dayalıdır; LOC ise tasarım odaklı ve dil bağımlıdır.",
        },
        {
          question: "Bilgi Akışı Metriklerinde ‘Fan-In’ neyi ifade eder?",
          options: [
            "Bir prosedürden çıkan veri akışını",
            "Bir prosedüre giren veri akışını",
            "Kod satır sayısını",
            "Programın işlevsel boyutunu",
            "Test süresini",
          ],
          correct: 1,
          explanation:
            "Fan-In, bir prosedüre giren yerel akışlar ve veri yapılarının sayısını ifade eder.",
        },
        {
          question:
            "Bilgi Akışı Metriklerinde prosedür karmaşıklığı nasıl hesaplanır?",
          options: [
            "Uzunluk * (Fan-In * Fan-Out)^2",
            "Fan-In / Fan-Out",
            "Uzunluk / (Fan-In + Fan-Out)",
            "Fan-In * Fan-Out",
            "Uzunluk * (Fan-In + Fan-Out)",
          ],
          correct: 0,
          explanation:
            "Prosedür karmaşıklığı, Uzunluk * (Fan-In * Fan-Out)^2 formülüyle hesaplanır.",
        },
        {
          question:
            "Siklomotik Karmaşıklık (Cyclomatic Complexity) neyi ölçer?",
          options: [
            "Kodun işlevsel boyutunu",
            "Kodun kontrol akış yollarının sayısını",
            "Programın kelime dağarcığını",
            "Kullanıcı girişlerini",
            "Veritabanı performansını",
          ],
          correct: 1,
          explanation:
            "Siklomotik Karmaşıklık, kodun kontrol akış grafiğindeki bağımsız yolların sayısını ölçer.",
        },
        {
          question: "Siklomotik Karmaşıklık formülü nedir?",
          options: [
            "M = E - N + 2P",
            "M = N - E + P",
            "M = E + N - P",
            "M = E / N + 2P",
            "M = E * N - P",
          ],
          correct: 0,
          explanation:
            "Siklomotik Karmaşıklık, M = E - N + 2P formülüyle hesaplanır; E: kenar sayısı, N: düğüm sayısı, P: bağlı bileşen sayısı.",
        },
        {
          question: "COCOMO modeli kaç farklı seviyede tanımlanmıştır?",
          options: ["İki", "Üç", "Dört", "Beş", "Altı"],
          correct: 1,
          explanation:
            "COCOMO modeli, Temel, Orta ve Ayrıntılı olmak üzere üç seviyede tanımlanmıştır.",
        },
        {
          question:
            "COCOMO modelinde ‘Organik’ mod hangi tür projeler için uygundur?",
          options: [
            "Yüksek karmaşıklıkta projeler",
            "Orta ölçekli ve deneyimli ekiplerin çalıştığı projeler",
            "Basit ve küçük ölçekli projeler",
            "Sıkı zaman kısıtlamaları olan projeler",
            "Yüksek riskli projeler",
          ],
          correct: 2,
          explanation:
            "Organik mod, basit ve küçük ölçekli projeler için uygundur.",
        },
        {
          question:
            "COCOMO modelinde çaba (Effort) hangi birimle ifade edilir?",
          options: [
            "KLOC",
            "Kişi-Ay (PM)",
            "Ay",
            "Hata Oranı",
            "Fonksiyonel Nokta",
          ],
          correct: 1,
          explanation:
            "COCOMO modelinde çaba, Kişi-Ay (Person-Months, PM) birimiyle ifade edilir.",
        },
        {
          question:
            "COCOMO modelinde geliştirme süresi (Tdev) hangi faktöre bağlıdır?",
          options: [
            "Kod satır sayısı",
            "Çaba (Effort)",
            "Kullanıcı girişleri",
            "Veritabanı boyutu",
            "Program kelime dağarcığı",
          ],
          correct: 1,
          explanation:
            "Geliştirme süresi (Tdev), çaba (Effort) miktarına bağlı olarak hesaplanır.",
        },
        {
          question: "Yazılım metrikleri hangi amaçla kullanılmaz?",
          options: [
            "Üretkenliği değerlendirmek",
            "Tasarım metodolojilerini karşılaştırmak",
            "Teknik personelin performansını değerlendirmek",
            "Kod karmaşıklığını analiz etmek",
            "Proje maliyetini tahmin etmek",
          ],
          correct: 2,
          explanation:
            "Yazılım metrikleri, ürün ve süreç yönetimi için faydalıdır ancak teknik personelin performansını değerlendirmek için uygun değildir.",
        },
        {
          question: "FPA’da ‘Count-total’ nasıl kullanılır?",
          options: [
            "Kod satır sayısını hesaplar.",
            "İşlevsel noktaları hesaplamak için ağırlıklarla çarpılır.",
            "Program uzunluğunu ölçer.",
            "Hata oranını belirler.",
            "Donanım gereksinimlerini analiz eder.",
          ],
          correct: 1,
          explanation:
            "FPA’da Count-total, ölçüm parametrelerinin ağırlıklarla çarpılmasıyla elde edilir ve işlevsel noktaları hesaplamak için kullanılır.",
        },
        {
          question: "LOC metrikleri hangi durumda yanıltıcı olabilir?",
          options: [
            "Kullanıcı odaklı projelerde",
            "Kötü yazılım tasarımı olduğunda",
            "Basit projelerde",
            "Test aşamasında",
            "Küçük ekiplerde",
          ],
          correct: 1,
          explanation:
            "Kötü yazılım tasarımı, gereksiz yere fazla kod satırına yol açarak LOC metriklerini yanıltıcı hale getirebilir.",
        },
        {
          question:
            "COCOMO modelinde ‘Semi-detached’ mod hangi tür projeler için uygundur?",
          options: [
            "Basit ve küçük ölçekli projeler",
            "Orta karmaşıklıkta ve ortalama deneyimli ekiplerin çalıştığı projeler",
            "Yüksek riskli ve karmaşık projeler",
            "Kullanıcı odaklı projeler",
            "Prototip odaklı projeler",
          ],
          correct: 1,
          explanation:
            "Semi-detached mod, orta karmaşıklıkta ve ortalama deneyimli ekiplerin çalıştığı projeler için uygundur.",
        },
        {
          question:
            "Yazılım metriklerinin uygulanmasında hangi zorlukla karşılaşılabilir?",
          options: [
            "Her zaman düşük maliyetlidir.",
            "Standartlaştırılmamış tanımlara dayanabilir.",
            "Kullanıcılar tarafından kolayca anlaşılır.",
            "Süreç yönetimini engeller.",
            "Kod satır sayısını ölçmez.",
          ],
          correct: 1,
          explanation:
            "Yazılım metriklerinin tanımı ve türetilmesi, standartlaştırılmamış varsayımlara ve araçlara bağlı olabilir, bu da uygulama zorluğu yaratır.",
        },
        {
          question:
            "Hangi metrik, yazılımın kullanıcı odaklı işlevselliğini ölçmek için en uygundur?",
          options: [
            "LOC",
            "Halstead Metrikleri",
            "Fonksiyonel Nokta Analizi",
            "Siklomotik Karmaşıklık",
            "Bilgi Akışı Metrikleri",
          ],
          correct: 2,
          explanation:
            "Fonksiyonel Nokta Analizi, yazılımın kullanıcı odaklı işlevselliğini ölçmek için en uygun yöntemdir.",
        },
      ];
      const pdf9 = [
        {
          question: "Proje nedir?",
          options: [
            "Sürekli tekrar eden bir iş sürecidir.",
            "Net bir sonuca ulaşmak için tamamlanması gereken görevler grubudur.",
            "Yalnızca donanım geliştirmeyi kapsar.",
            "Müşteri gereksinimlerini belirlemeyi amaçlar.",
            "Yazılım test sürecini tanımlar.",
          ],
          correct: 1,
          explanation:
            "Proje, belirli bir hedefe ulaşmak için tamamlanması gereken bir dizi görevdir ve net bir sonuç üretmeyi amaçlar.",
        },
        {
          question:
            "Bir projenin yürütülmesi için genellikle kim tarafından tanımlanır ve onaylanır?",
          options: [
            "Müşteri",
            "Proje yöneticisi",
            "Yazılım geliştirici",
            "Donanım mühendisi",
            "Kalite kontrol ekibi",
          ],
          correct: 1,
          explanation:
            "Projeler genellikle bir proje yöneticisi veya ekip yöneticisi tarafından tanımlanır ve onaylanır.",
        },
        {
          question: "Yazılım proje yönetimi nedir?",
          options: [
            "Yazılımın yalnızca kodlama sürecini yönetir.",
            "Yazılım projelerini planlama ve denetleme disiplinidir.",
            "Donanım kaynaklarını optimize etmeyi amaçlar.",
            "Müşteri sözleşmelerini hazırlama sürecidir.",
            "Yazılımın yalnızca test aşamasını kapsar.",
          ],
          correct: 1,
          explanation:
            "Yazılım proje yönetimi, yazılım projelerinin planlandığı, uygulandığı, izlendiği ve kontrol edildiği bir disiplindir.",
        },
        {
          question: "Yazılım proje yönetiminin temel önkoşulları nelerdir?",
          options: [
            "Zaman, maliyet, kalite",
            "Ekip, donanım, yazılım",
            "Planlama, test, bakım",
            "Müşteri, bütçe, risk",
            "Geliştirme, izleme, raporlama",
          ],
          correct: 0,
          explanation:
            "Yazılım proje yönetimi için temel önkoşullar zaman, maliyet ve kalitedir.",
        },
        {
          question:
            "Yazılım proje yönetiminde üçlü faktörden (zaman, maliyet, kalite) biri diğerlerini nasıl etkiler?",
          options: [
            "Hiçbir etkisi yoktur.",
            "Diğer ikisini ciddi şekilde etkileyebilir.",
            "Yalnızca maliyeti etkiler.",
            "Yalnızca kaliteyi etkiler.",
            "Sadece zamanı etkiler.",
          ],
          correct: 1,
          explanation:
            "Zaman, maliyet veya kalitedeki bir değişiklik, diğer iki faktörü ciddi şekilde etkileyebilir.",
        },
        {
          question: "Proje yöneticisinin genel sorumluluğu nedir?",
          options: [
            "Yazılım kodunu yazmak",
            "Projenin planlanması, yürütülmesi ve kapatılmasından sorumlu olmak",
            "Donanım kaynaklarını tedarik etmek",
            "Müşteriyle yalnızca sözleşme görüşmeleri yapmak",
            "Yazılımın testlerini gerçekleştirmek",
          ],
          correct: 1,
          explanation:
            "Proje yöneticisi, projenin planlanması, tasarlanması, yürütülmesi, izlenmesi, kontrol edilmesi ve kapatılmasından sorumludur.",
        },
        {
          question: "Proje yöneticisinin lider olarak rolü nedir?",
          options: [
            "Müşterilerle doğrudan sözleşme yapmak",
            "Ekibe yön vermek ve beklentileri açıklamak",
            "Yazılımın teknik tasarımını oluşturmak",
            "Donanım gereksinimlerini belirlemek",
            "Test süreçlerini yönetmek",
          ],
          correct: 1,
          explanation:
            "Proje yöneticisi, lider olarak ekibe yön verir ve kendilerinden ne beklendiğini anlamalarını sağlar.",
        },
        {
          question: "Proje yöneticisinin ‘ara bulucu’ rolü neyi ifade eder?",
          options: [
            "Ekibi teknik konularda eğitmek",
            "Müşteriler ve ekip arasında bilgi akışını koordine etmek",
            "Yazılımın kod kalitesini kontrol etmek",
            "Proje bütçesini belirlemek",
            "Risk analizleri yapmak",
          ],
          correct: 1,
          explanation:
            "Ara bulucu olarak proje yöneticisi, müşterilerden gelen bilgileri ekibe aktarır ve üst yönetime rapor verir.",
        },
        {
          question:
            "Proje yöneticisinin ‘akıl hocası’ rolü aşağıdakilerden hangisini içerir?",
          options: [
            "Proje bütçesini yönetmek",
            "Ekibe rehberlik etmek ve doğru yöne yönlendirmek",
            "Yazılımın testlerini yapmak",
            "Müşteri gereksinimlerini belirlemek",
            "Donanım kaynaklarını tahsis etmek",
          ],
          correct: 1,
          explanation:
            "Akıl hocası olarak proje yöneticisi, ekibe her adımda rehberlik eder ve onları doğru yöne yönlendirir.",
        },
        {
          question:
            "Proje yöneticisinin sorumluluklarından biri aşağıdakilerden hangisidir?",
          options: [
            "Yazılımın kodlamasını yapmak",
            "Riskleri ve sorunları yönetmek",
            "Donanım tasarımı yapmak",
            "Müşteriyle yalnızca pazarlama görüşmeleri yapmak",
            "Veritabanı yönetimini gerçekleştirmek",
          ],
          correct: 1,
          explanation:
            "Proje yöneticisi, riskleri ve sorunları yönetmekle sorumludur.",
        },
        {
          question:
            "Yazılım proje yönetimi aktivitelerinden biri aşağıdakilerden hangisidir?",
          options: [
            "Donanım testi",
            "Proje risk yönetimi",
            "Veritabanı tasarımı",
            "Kullanıcı arayüzü geliştirme",
            "Kod optimizasyonu",
          ],
          correct: 1,
          explanation:
            "Proje risk yönetimi, yazılım proje yönetimi aktivitelerinden biridir.",
        },
        {
          question: "Yazılım proje yönetiminde maliyet tahmini neleri içerir?",
          options: [
            "Yalnızca yazılım geliştirme maliyetini",
            "Donanım, yazılım ve çaba maliyetlerini",
            "Sadece müşteri bütçesini",
            "Yalnızca test maliyetlerini",
            "Sadece bakım maliyetlerini",
          ],
          correct: 1,
          explanation:
            "Maliyet tahmini, donanım, yazılım, seyahat, eğitim ve çaba (programcı ve diğerleri) maliyetlerini içerir.",
        },
        {
          question:
            "Maliyet tahmini yaparken aşağıdakilerden hangisi bir faktördür?",
          options: [
            "Kullanıcı arayüzü tasarımı",
            "Pazar fırsatları",
            "Yazılımın kod satır sayısı",
            "Donanım performansı",
            "Veritabanı yapısı",
          ],
          correct: 1,
          explanation:
            "Pazar fırsatları, maliyet tahmini yaparken dikkate alınan bir faktördür.",
        },
        {
          question: "Aşağıdakilerden hangisi bir yazılım proje metriğidir?",
          options: [
            "Donanım hızı",
            "Fonksiyonel Noktalar (FP)",
            "Veritabanı boyutu",
            "Arayüz renkleri",
            "Kullanıcı sayısı",
          ],
          correct: 1,
          explanation:
            "Fonksiyonel Noktalar (FP), yazılım proje yönetiminde kullanılan bir metriktir.",
        },
        {
          question: "Algoritmik maliyet modellemesi nedir?",
          options: [
            "Müşteri bütçesine göre maliyet belirleme",
            "Geçmiş projelerin maliyet bilgilerine dayalı tahmin",
            "Yazılımın kod satır sayısını ölçme",
            "Kullanıcı gereksinimlerini analiz etme",
            "Donanım gereksinimlerini belirleme",
          ],
          correct: 1,
          explanation:
            "Algoritmik maliyet modellemesi, geçmiş projelerin maliyet bilgilerine dayalı bir tahmin yöntemidir.",
        },
        {
          question:
            "Uzman yargısı (Expert Judgement) tahmin tekniği neye dayanır?",
          options: [
            "Bir veya daha fazla uzmanın görüşüne",
            "Yazılımın kod satır sayısına",
            "Müşteri bütçesine",
            "Donanım gereksinimlerine",
            "Veritabanı yapısına",
          ],
          correct: 0,
          explanation:
            "Uzman yargısı, bir veya daha fazla uzmanın deneyimine ve görüşüne dayalı bir tahmin tekniğidir.",
        },
        {
          question:
            "Analojiyle tahmin (Estimation by Analogy) hangi durumlarda kullanılır?",
          options: [
            "Yazılımın test aşamasında",
            "Aynı uygulama alanında önceki projelere dayalı olarak",
            "Müşteri bütçesine göre",
            "Yazılımın kod satır sayısına dayalı olarak",
            "Donanım gereksinimlerine göre",
          ],
          correct: 1,
          explanation:
            "Analojiyle tahmin, aynı uygulama alanındaki önceki projelere dayalı olarak yapılır.",
        },
        {
          question: "Parkinson Yasası’na göre maliyet tahmini nasıl yapılır?",
          options: [
            "Müşteri gereksinimlerine göre",
            "Kullanılabilir kaynaklara göre",
            "Yazılımın işlevselliğine göre",
            "Kod satır sayısına göre",
            "Test süresine göre",
          ],
          correct: 1,
          explanation:
            "Parkinson Yasası’na göre maliyet, kullanılabilir kaynaklara (örneğin, kişi ve süre) göre tanımlanır.",
        },
        {
          question: "‘Pricing to Win’ tahmin tekniği neye odaklanır?",
          options: [
            "Yazılımın işlevselliğine",
            "Müşterinin mevcut bütçesine",
            "Kod satır sayısına",
            "Proje risklerine",
            "Donanım gereksinimlerine",
          ],
          correct: 1,
          explanation:
            "Pricing to Win, maliyetin müşterinin mevcut bütçesine göre belirlendiği bir tahmin tekniğidir.",
        },
        {
          question:
            "Yukarıdan aşağıya (Top-down) tahmin tekniği neyi dikkate alır?",
          options: [
            "Her bileşenin ayrı ayrı maliyetini",
            "Sistemin genel işlevselliğini",
            "Yazılımın kod satır sayısını",
            "Donanım gereksinimlerini",
            "Test süreçlerini",
          ],
          correct: 1,
          explanation:
            "Yukarıdan aşağıya tahmin, sistemin genel işlevselliğini dikkate alarak maliyet tahmini yapar.",
        },
        {
          question:
            "Aşağıdan yukarıya (Bottom-up) tahmin tekniği nasıl çalışır?",
          options: [
            "Sistemin genel işlevselliğini analiz eder.",
            "Her bileşenin maliyetini ayrı ayrı hesaplar.",
            "Müşteri bütçesine odaklanır.",
            "Yazılımın kod satır sayısını ölçer.",
            "Donanım gereksinimlerini belirler.",
          ],
          correct: 1,
          explanation:
            "Aşağıdan yukarıya tahmin, her bileşenin maliyetini ayrı ayrı hesaplayarak toplam maliyeti belirler.",
        },
        {
          question:
            "COCOMO modelinde ‘Organik’ mod hangi tür projeler için uygundur?",
          options: [
            "Karmaşık ve yüksek gereksinimlere sahip projeler",
            "Küçük ekiplerle iyi iletişim kurulan projeler",
            "Deneyimli ve deneyimsiz geliştiricilerin olduğu projeler",
            "Sıkı zaman kısıtlamaları olan projeler",
            "Yüksek riskli projeler",
          ],
          correct: 1,
          explanation:
            "Organik mod, küçük ekiplerle iyi iletişim kurulan basit projeler için uygundur.",
        },
        {
          question:
            "COCOMO modelinde ‘Semi-detached’ mod hangi tür ekipler için uygundur?",
          options: [
            "Yalnızca deneyimli geliştiricilerden oluşan ekipler",
            "Deneyimli ve deneyimsiz geliştiricilerin bir arada olduğu ekipler",
            "Küçük ve iletişim odaklı ekipler",
            "Yüksek riskli projeler için ekipler",
            "Test odaklı ekipler",
          ],
          correct: 1,
          explanation:
            "Semi-detached mod, deneyimli ve deneyimsiz geliştiricilerin bir arada çalıştığı projeler için uygundur.",
        },
        {
          question:
            "COCOMO modelinde ‘Embedded’ mod hangi tür projeler için uygundur?",
          options: [
            "Basit ve küçük ölçekli projeler",
            "Karmaşık gereksinimlere sahip projeler",
            "Kullanıcı odaklı projeler",
            "Prototip odaklı projeler",
            "Kısa süreli projeler",
          ],
          correct: 1,
          explanation:
            "Embedded mod, karmaşık gereksinimlere ve donanım/proses ihtiyaçlarına sahip projeler için uygundur.",
        },
        {
          question:
            "Yazılım proje yönetiminde ‘kapsam yönetimi’ neyi ifade eder?",
          options: [
            "Proje ekibinin oluşturulmasını",
            "Projenin hedef ve teslimatlarının tanımlanmasını",
            "Maliyet tahminini",
            "Donanım kaynaklarının tahsisini",
            "Yazılımın test sürecini",
          ],
          correct: 1,
          explanation:
            "Kapsam yönetimi, projenin hedeflerini, teslimatlarını ve sınırlarını tanımlamayı içerir.",
        },
        {
          question:
            "Proje yöneticisi hangi durumda proje planını değiştirebilir?",
          options: [
            "Müşteri bütçesi değiştiğinde",
            "Durumla başa çıkmak için",
            "Yazılım kodlaması tamamlandığında",
            "Donanım gereksinimleri belirlendiğinde",
            "Test süreci başladığında",
          ],
          correct: 1,
          explanation:
            "Proje yöneticisi, durumla başa çıkmak için proje planını değiştirebilir.",
        },
        {
          question:
            "Yazılım proje yönetiminde hangi aktivite ilerlemeyi izlemeyi içerir?",
          options: [
            "Proje planlama ve takip",
            "Kaynak yönetimi",
            "Risk yönetimi",
            "İletişim yönetimi",
            "Yapılandırma yönetimi",
          ],
          correct: 0,
          explanation:
            "Proje planlama ve takip aktivitesi, ilerlemeyi izlemeyi ve raporlamayı içerir.",
        },
        {
          question:
            "Maliyet tahmini yaparken ‘gereksinim oynaklığı’ neyi ifade eder?",
          options: [
            "Müşteri gereksinimlerinin sık değişmesi",
            "Yazılımın kod satır sayısının artması",
            "Donanım gereksinimlerinin değişmesi",
            "Test süresinin uzaması",
            "Ekip üyelerinin değişmesi",
          ],
          correct: 0,
          explanation:
            "Gereksinim oynaklığı, müşteri gereksinimlerinin sık değişmesini ifade eder ve maliyet tahminini etkiler.",
        },
        {
          question:
            "Hangi tahmin tekniği, yazılımın işlevselliği yerine bütçeye odaklanır?",
          options: [
            "Algoritmik maliyet modellemesi",
            "Uzman yargısı",
            "Pricing to Win",
            "Analojiyle tahmin",
            "Yukarıdan aşağıya tahmin",
          ],
          correct: 2,
          explanation:
            "Pricing to Win, maliyetin işlevsellikten ziyade müşterinin bütçesine göre belirlendiği bir tekniktir.",
        },
        {
          question:
            "Proje yöneticisinin hangi rolü, ekibin bağlılığını sağlamayı amaçlar?",
          options: [
            "Lider",
            "Ara bulucu",
            "Akıl hocası",
            "Planlayıcı",
            "Raporlayıcı",
          ],
          correct: 2,
          explanation:
            "Akıl hocası olarak proje yöneticisi, ekibin bağlılığını sağlamak için rehberlik eder ve tavsiyelerde bulunur.",
        },
      ];
      const questionsModel8 = [
        {
          question:
            "Aşağıdakilerden hangisi proje yöneticisinin sorumluluklarından değildir?",
          options: [
            "Riskleri ve sorunları yönetmek",
            "Faaliyet planlama ve sıralama",
            "İlerlemenin izlenmesi ve raporlanması",
            "Projenin planını hiçbir zaman değiştirmez",
            "Müşterilerden gelen talepleri ekibine aktarır",
          ],
          correct: 3,
          explanation:
            "Proje yöneticisi, değişiklikler, riskler veya sorunlar karşısında proje planını gerektiğinde uyarlar, bu nedenle 'planı hiçbir zaman değiştirmez' ifadesi doğru değildir.",
        },
        {
          question:
            "LOC Metrics kullanılarak yapılan normalleştirme işleminin temel amacı nedir?",
          options: [
            "Yazılan kodun çalışma süresini optimize etme",
            "Kodun görsel tasarımını iyileştirme",
            "Farklı büyüklükteki projeleri karşılaştırıl",
            "Programcıların yazdığı kodun dilini standartlaştırmak",
            "Yazılımın bellek kullanımını analiz etmek",
          ],
          correct: 2,
          explanation:
            "LOC (Satır Sayısı) metrikleriyle normalleştirme, farklı büyüklükteki projeleri karşılaştırmak için kod boyutunu standartlaştırmayı amaçlar.",
        },
        {
          question:
            "Aşağıdakilerden hangisi maliyet tahminini etkileyen faktörlerden biri değildir?",
          options: [
            "Pazar fırsatları",
            "Gereksinim değişkenliği",
            "Finansal zorluk",
            "Yazılım tasarım kalitesi",
            "Sözleşme şartları",
          ],
          correct: 0,
          explanation:
            "Pazar fırsatları, maliyet tahminini doğrudan etkileyen bir faktör değildir; diğer seçenekler (gereksinim değişkenliği, finansal zorluk, tasarım kalitesi, sözleşme şartları) maliyet tahminine doğrudan etki eder.",
        },
        {
          question:
            "Yazılım süreç modelleri hakkında aşağıda verilen bilgilerden hangileri yanlıştır?",
          options: ["Hepsi", "I ve II", "II ve III", "Yalnız IV", "Hiçbiri"],
          correct: 2,
          explanation:
            "II (Çağlayan modeli üretimi az zaman gerektiren projeler için uygun değildir) ve III (9 adet yazılım süreci modeli yoktur) ifadeleri yanlıştır.",
        },
        {
          question:
            "Aşağıdakilerden hangisi Çevik (Agile) yazılım geliştirme yaklaşımının temel ilkelerinden biri değildir?",
          options: [
            "Değişken gereksinimlere karşılık verme",
            "Müşteriyle sürekli iletişim ve işbirliği",
            "Ayrıntılı ve kapsamlı dokümana öncelik verilmesi",
            "Çalışan yazılımın temel başarı ölçütü olarak kabul edilmesi",
            "Kendi kendini organize eden ekiplerin desteklenmesi",
          ],
          correct: 2,
          explanation:
            "Çevik yaklaşım, ayrıntılı dokümantasyon yerine çalışan yazılıma öncelik verir, bu nedenle kapsamlı dokümana öncelik verilmesi bir ilke değildir.",
        },
        {
          question:
            "Halstead yazılım metriklerine göre hacim (volume) aşağıdakilerden hangisine bağlıdır?",
          options: [
            "Sadece operand sayısına",
            "Kodun test süresine",
            "Toplam belirteç (token) sayısına ve kelime dağarcığına (vocabulary)",
            "Satır sayısına",
            "Donanım türüne",
          ],
          correct: 2,
          explanation:
            "Halstead metriklerinde hacim, toplam belirteç (operator ve operand) sayısı ile kelime dağarcığına (benzersiz belirteçler) bağlıdır.",
        },
        {
          question:
            "Aşağıdaki maliyet tahmini tekniklerinden hangisi geçmişte benzer uygulama alanındaki projelere bakılarak yapılan tahmin yöntemidir?",
          options: [
            "Parkinson yasası",
            "Expert Judgement",
            "Algoritmik cost model",
            "Estimation by Analogy",
            "Bottom-up Estimation",
          ],
          correct: 3,
          explanation:
            "Estimation by Analogy, geçmişte benzer projelere dayalı maliyet tahmini yapar.",
        },
        {
          question:
            "Fonksiyon Noktası Analizi bir yazılım projesinde yazılımın hangi yönünü ölçmekte fazla kullanılır?",
          options: [
            "Kod satır sayısını",
            "Yazılımın işlevsel boyutunu (üzerinde kullanıcı fonksiyonları)",
            "Yazılımın derlenme süresini",
            "Yazılımın bellek kullanımını",
            "Yazılımın güvenlik düzeyini",
          ],
          correct: 1,
          explanation:
            "Fonksiyon Noktası Analizi, yazılımın işlevsel boyutunu (kullanıcı işlevselliğini) ölçmek için kullanılır.",
        },
        {
          question:
            "Aşağıdaki projelerden hangisi için helezonik yazılım süreci modeli değerlerine göre daha uygun bir seçim olur?",
          options: [
            "Gereksinimlerin tam olarak belirlendiği ve müşteri tarafından belgelenmiş küçük ölçekli bir hesap makinesi",
            "İhtiyacın sabit olduğu ve değişkenlik göstermeyen, eğitim amaçlı bir öğrenci bilgi sistemi",
            "Risklerin yüksek olduğu, müşteri geri bildirimlerinin sürekli alınması gereken büyük ölçekli bir savunma sanayi yazılım projesi",
            "Önceden benzeri geliştirilmiş, karmaşıklığı düşük olan bir bordro yönetim sistemi",
            "Gereksinimlerin çok net olmadığı, prototiplerin önem taşımadığı, kısa sürede tamamlanması gereken küçük bir mobil oyun uygulaması",
          ],
          correct: 2,
          explanation:
            "Helezonik model, yüksek riskli ve müşteri geri bildirimine dayalı büyük ölçekli projeler için uygundur, bu nedenle savunma sanayi projesi en uygun seçimdir.",
        },
        {
          question:
            "Aşağıdakilerden hangisi Function Point Analysis (FPA) ile ilgili doğru bir ifadedir?",
          options: [
            "FPA sadece yazılım kod satırlarını sayarak işlevselliği ölçer.",
            "FPA yazılımın fiziksel büyüklüğü yerine işlevsel büyüklüğünü ölçer.",
            "FPA yalnızca sistemin donanım bağımlılıklarını analiz etmek için kullanılır.",
            "FPA, Halstead metrikleri ile aynı formülleri kullanır.",
            "FPA sadece nesne yönelimli yazılımlarda uygulanabilir.",
          ],
          correct: 1,
          explanation:
            "FPA, yazılımın işlevsel büyüklüğünü (kullanıcı işlevselliğini) ölçer, kod satır sayısına odaklanmaz.",
        },
        {
          question:
            "COCOMO modelinde organik mod hangi tür projelere uygundur?",
          options: [
            "Küçük, iyi anlaşılmış projeler; karışık deneyimli küçük ekip",
            "Orta büyüklükte, kısmen bilinmeyen projeler",
            "Büyük, gömülü sistem projeleri, ciddi kısıtlamalar altında",
            "Yalnızca R&D projeleri için özel bir mod",
            "Kod satır sayısının çok yüksek olduğu her proje",
          ],
          correct: 0,
          explanation:
            "COCOMO organik mod, küçük ve iyi anlaşılmış projeler ile deneyimli küçük ekipler için uygundur.",
        },
        {
          question:
            "Aşağıdakilerden hangisi yazılım sürecindeki geçerleme (validation) adımı ile doğrudan ilgilidir?",
          options: [
            "Yazılım kaynak kodlarını gözden geçirme",
            "Gereksinimlerin kullanıcı ihtiyaçlarını karşıladığını kanıtlama",
            "Algoritma tasarımı yapma",
            "Donanım gereksinimlerini çıkarma",
            "Veri tabanı tablolarını oluşturma",
          ],
          correct: 1,
          explanation:
            "Geçerleme (validation), yazılımın kullanıcı ihtiyaçlarını karşıladığını doğrulama sürecidir.",
        },
        {
          question:
            "Aşağıdakilerden hangisi Halstead metriklerinden biri değildir?",
          options: [
            "Program söz varlığı (vocabulary)",
            "Program uzunluğu (length)",
            "Program hacmi (volume)",
            "Döngüsel karmaşıklık (cyclomatic complexity)",
            "Zorluk (difficulty)",
          ],
          correct: 3,
          explanation:
            "Döngüsel karmaşıklık, McCabe tarafından tanımlanan bir metrik olup Halstead metrikleri arasında yer almaz.",
        },
        {
          question:
            "LOC (Lines of Code) metriği ile ilgili aşağıdaki ifadelerden hangisi doğrudur?",
          options: [
            "Tüm programlama dillerinde bağımsız çalışır",
            "Yazılımın işlevselliğini en iyi şekilde ölçer",
            "Sadece nesne tabanlı yazılımlar için uygundur",
            "Programcıların verimliliğini ölçmek için kullanılabilir",
            "Yazılımın maliyeti hakkında bilgi vermez",
          ],
          correct: 3,
          explanation:
            "LOC metriği, programcıların verimliliğini ölçmek için kullanılabilir, ancak programlama diline bağlıdır ve işlevselliği doğrudan ölçmez.",
        },
        {
          question:
            "Aşağıdakilerden hangisi Spiral Modelin bir avantajı değildir?",
          options: [
            "Risk analizine dayalı bir yaklaşım benimsenmesi",
            "Projenin küçük parçalara bölünmesi",
            "Kullanıcının sistemi erken görebilmesi",
            "Gereksinimlerin baştan tam olarak belirlenmesi gerekliliği",
            "Proje sürecinde kullanıcı değerlendirmelerine yer verilmesi",
          ],
          correct: 3,
          explanation:
            "Spiral Model, gereksinimlerin baştan tam olarak belirlenmesini gerektirmez; bu, Şelale Modeli için daha tipiktir.",
        },
        {
          question:
            "'Pricing to win' yaklaşımı hangi duruma dayanarak maliyet tahmini yapar?",
          options: [
            "Yazılım fonksiyonel gereksinimlere",
            "Kullanıcı arayüzünün karmaşıklığına",
            "Mevcut bütçeye",
            "Donanım gereksinimlerine",
            "Takımın büyüklüğüne",
          ],
          correct: 2,
          explanation:
            "'Pricing to win', mevcut bütçeye göre maliyet tahmini yaparak rekabet avantajı sağlamayı amaçlar.",
        },
        {
          question:
            "Yazılım süreç modelleri ile ilgili aşağıdakilerden hangisi yanlıştır?",
          options: [
            "Süreçlerin düzenli bir şekilde işlemesini sağlar",
            "Yazılımın sadece kodlama aşamasını kapsar",
            "Geliştiricilerin karmaşıklıkla baş etmesine yardımcı olur",
            "Ürünün kalitesini etkileyebilir",
            "Geliştirici ve yöneticiye rehberlik eder",
          ],
          correct: 1,
          explanation:
            "Yazılım süreç modelleri, yalnızca kodlama aşamasını değil, tüm yaşam döngüsünü kapsar.",
        },
        {
          question:
            "Aşağıdakilerden hangisi Yazılım Yaşam Döngüsünün Temel Adımları arasında değildir?",
          options: ["Planlama", "Analiz", "Tasarım", "Geridönüt", "Bakım"],
          correct: 3,
          explanation:
            "Yazılım Yaşam Döngüsü’nün temel adımları arasında 'geri dönüş' (geridönüt) yer almaz; genellikle planlama, analiz, tasarım, uygulama ve bakım adımları bulunur.",
        },
        {
          question:
            "Şelale (Waterfall) modeline ilişkin aşağıdakilerden hangisi yanlıştır?",
          options: [
            "Süreç adımları sıralı ve aşamalı bir şekilde gerçekleştirilir.",
            "Geri dönüşler tamamen yasaktır, her aşama yalnızca bir kez yapılır.",
            "Belgeleme doğal bir süreç olarak kabul edilir.",
            "Gereksinimlerin net olduğu projeler için uygundur.",
            "Geleneksel model olarak da adlandırılır.",
          ],
          correct: 1,
          explanation:
            "Şelale modelinde geri dönüşler tamamen yasak değildir; sınırlı durumlarda önceki aşamalara dönülebilir.",
        },
        {
          question:
            "Helezonik (Spiral) modelin en belirgin avantajlarından biri aşağıdakilerden hangisidir?",
          options: [
            "Belgelemenin ayrı bir aşama olarak ele alınması",
            "Projeyi tek bir döngüde tamamlayarak zaman kazandırması",
            "Kullanıcıların sürece erken katılımını teşvik ederek riskleri azaltması",
            "Gereksinimlerin baştan kesin ve değişmez kabul edilmesi",
            "Kodlamanın tüm geliştirme sürecinden sonra başlaması",
          ],
          correct: 2,
          explanation:
            "Helezonik model, kullanıcıların erken katılımını teşvik ederek riskleri azaltır ve prototip odaklıdır.",
        },
        {
          question:
            "Aşağıdaki projelerden hangisi için COCOMO modelinde gömülü mod kullanılması uygundur?",
          options: [
            "Bir öğrencinin geliştirdiği kişisel web sitesi",
            "Küçük ölçekli bir stok takip uygulaması",
            "Mobil cihazlar için planlanmış bir oyun uygulaması",
            "Gerçek zamanlı çalışan bir kalp atış izleme cihazı yapımı",
            "Küçük bir ekip tarafından geliştirilen blog yazılım sistemi",
          ],
          correct: 3,
          explanation:
            "COCOMO gömülü mod, ciddi kısıtlamalar altında çalışan, gerçek zamanlı gömülü sistem projeleri (ör. kalp atış izleme cihazı) için uygundur.",
        },
      ];
      const questionsModel7 = [
        {
          question: "What is the primary function of a compiler?",
          options: [
            "To execute a program's source code line by line",
            "To translate a program written in a high-level language into machine code",
            "To manage and store software development documents",
            "To handle memory allocation for dynamic data structures",
            "To interpret code written in a scripting language",
          ],
          correct: 1,
          explanation:
            "A compiler's primary role is to translate high-level source code into machine code that a computer can execute, distinguishing it from interpreters which execute code line by line.",
        },
        {
          question:
            "Aşağıdakilerden hangisi bir yazılım test seviyesi değildir?",
          options: [
            "Birim Testi (Unit Testing)",
            "Entegrasyon Testi (Integration Testing)",
            "Sistem Testi (System Testing)",
            "Kullanıcı Kabul Testi (User Acceptance Testing)",
            "Prototip Testi (Prototype Testing)",
          ],
          correct: 4,
          explanation:
            "Prototip Testi, bir yazılım test seviyesi değildir; diğer seçenekler (Birim, Entegrasyon, Sistem ve Kullanıcı Kabul Testleri) yazılım geliştirme sürecinde standart test seviyeleridir.",
        },
        {
          question:
            "Bakım sorunları hakkında aşağıda verilen ifadelerden hangisi yanlıştır?",
          options: [
            "Bakım sırasında karşılaşabilecek sorunları bilmek o sorunlara önlem almayı kolaylaştırır.",
            "Belgelendirme ve kod içindeki açıklamalar ne kadar iyiyse bakım o kadar kolaylaşır.",
            "Yazılım sürüm sayısını artırmak bakımı zorlaştırır.",
            "Yazılım geliştirildiği süreci aynen takip etmek zaman ve iş gücünden tasarruf sağlar.",
            "Yazılım işlevsel modüllere bölmek sonradan yapılacak değişiklikleri kolaylaştırır.",
          ],
          correct: 3,
          explanation:
            "Yazılım geliştirildiği süreci aynen takip etmek genellikle bakımda tasarruf sağlamaz, çünkü zamanla değişen gereksinimler ve teknolojiler eski süreci geçersiz kılabilir.",
        },
        {
          question:
            "Aşağıdaki ifadelerden hangisi, Yazılım Geliştirme Yaşam Döngüsü'nün 'Spiral Model' ile ilgili doğru bir açıklama yapmaktadır?",
          options: [
            "Spiral Model, yalnızca yazılımın kodlama ve test aşamalarını içerir ve diğer aşamaları dışlar.",
            "Spiral Model, her aşamada müşteri geri bildirimlerini dikkate almaz ve tamamen iç geliştirme süreçlerine odaklanır.",
            "Spiral Model, yazılım geliştirme sürecinde risk analizi ve yönetimini önemli bir odak noktası olarak belirler.",
            "Spiral Model, yazılım geliştirme sürecini bir dizi kısa, sabit süreli iterasyonlara böler ve her iterasyon sonunda çalışma yazılımı teslim eder.",
            "Spiral Model, Çağlayan modeli gibi katı aşamaların sırasını takip eder ve geri dönüşlere izin vermez.",
          ],
          correct: 2,
          explanation:
            "Spiral Model, risk analizi ve yönetimine odaklanır, bu da onu diğer modellerden ayıran temel özelliktir.",
        },
        {
          question: "Hangi modelde Risk Analizi Olgusu ön plana çıkmıştır?",
          options: [
            "Helezonoik model",
            "Çağlayan model",
            "V model",
            "Evrimsel geliştirme süreç modeli",
            "Gelişigüzel model",
          ],
          correct: 0,
          explanation:
            "Helezonoik model (Spiral Model), risk analizini merkeze alır ve bu özelliğiyle öne çıkar.",
        },
        {
          question:
            "Aşağıdakilerden hangisi Uç Programlama modelinin 12 Yöntemlerinden birisi değildir?",
          options: [
            "Çifte Programlama (Pair Programming)",
            "Plan Oyunu (The Planning Game)",
            "Metafor (Metaphor)",
            "Çifte Test (Pair Testing)",
            "Yerinde müşteri (On-Site Customer)",
          ],
          correct: 3,
          explanation:
            "Çifte Test (Pair Testing), Extreme Programming’in 12 yönteminden biri değildir; diğerleri bu metodolojinin temel prensiplerindendir.",
        },
        {
          question:
            "Aşağıdakilerden hangisi doğru bir Sürüm Numaralandırma örneğidir?",
          options: [
            "1.0.0-M1 -> 1.0.0-RC1 -> 1.0.0-M2 -> 1.0.0-RC2 -> 1.0.0 -> 1.1.0",
            "2.0.0-RC1 -> 2.0.0-RC2 -> 2.0.0-M1 -> 2.0.0-M2 -> 2.0.0 -> 2.0.1",
            "1.0.0-M1 -> 2.0.0-M2 -> 2.1.0-RC1 -> 2.2.0-RC2 -> 2.2.0 -> 2.3.0",
            "2.0.0-M1 -> 2.0.0-M2 -> 2.0.0-RC1 -> 2.0.0-RC2 -> 2.0.0 -> 2.0.1",
            "1.0.0-RC1 -> 1.0.0-M1 -> 1.0.0-RC2 -> 1.0.0-M2 -> 1.0.0 -> 1.1.0",
          ],
          correct: 3,
          explanation:
            "Doğru sürüm numaralandırma, milestone (M) ve release candidate (RC) aşamalarının mantıklı bir sırayla ilerlemesini gerektirir; D seçeneği bu sırayı doğru yansıtır.",
        },
        {
          question:
            "Aşağıdakilerden hangisi yazılım test stratejileri ile ilgili yanlış bir bilgidir?",
          options: [
            "Geçerleme testlerinde doğru ürünün üretilip üretilmediğine bakılır.",
            "Tümleştirme testinde birimler bir araya getirilerek test edilir.",
            "Beta testleri geliştiricinin kendi ortamında yapılır.",
            "Birim test yönteminde yazılım birimlere ayrılarak test edilir.",
            "Geliştiriciler alfa testlerine dahil olur.",
          ],
          correct: 2,
          explanation:
            "Beta testleri, genellikle geliştiricinin ortamında değil, gerçek kullanıcıların ortamında yapılır.",
        },
        {
          question:
            "Aşağıdaki yazılım geliştirme sonuçlarından hangisi (diğerlerine göre daha çok) performans ve güvenlik gibi kavramlar göz önüne alınarak gerçekleştirilir?",
          options: [
            "Analiz",
            "Tasarım",
            "Unit testler",
            "Bakım",
            "Production ortam",
          ],
          correct: 1,
          explanation:
            "Tasarım aşamasında, performans ve güvenlik gibi unsurlar sistem mimarisine entegre edilir.",
        },
        {
          question:
            "Aşağıdakilerden hangisi çevik (agile) manifestonun prensipleri arasında yer almaz?",
          options: [
            "Bilgin  takımlar içerisinde ya da takımlar arasında en iyi paylaşılması ve anlaşılmasının yolu yüz yüze iletişimdir.",
            "Basitlik önemlidir.",
            "En iyi mimari, gereksinimler ve tasarımlar sadece yönetim tarafından organize edilebilen takımlardan çıkar.",
            "İlerlemenin en iyi göstergesi çalışan yazılımdır.",
            "Geliştiriciler ve iş insanları proje boyunca beraber çalışmalıdırlar.",
          ],
          correct: 2,
          explanation:
            "Çevik manifesto, öz-yönetimli takımları teşvik eder; yönetimin tek başına organizasyonu bir çevik prensip değildir.",
        },
        {
          question:
            "Bir yazılım projesinde, ekip değişikliklere hızlı yanıt verebilmeli ve müşteriyle sürekli etkileşim halinde olabilmelidir. Bu özellikler göz önüne alındığında, aşağıdaki süreç modellerinden hangisini tercih etmek uygun olacaktır?",
          options: [
            "V Modeli",
            "Spiral Model",
            "Çevik (Agile) Model",
            "Çift Aşamalı Geliştirme Modeli",
            "Su Çiçeği Modeli",
          ],
          correct: 2,
          explanation:
            "Çevik model, esneklik ve müşteriyle sürekli iletişim gerektiren projeler için idealdir.",
        },
        {
          question:
            "Aşağıdaki yazılım geliştirme sonuçlarından hangisinde (en fazla) performans ve güvenlik gibi kavramlar göz önüne alınarak gerçekleştirilmektedir?",
          options: [
            "Analiz",
            "Tasarım",
            "Unit testler",
            "Bakım",
            "Production ortam",
          ],
          correct: 1,
          explanation:
            "Tasarım aşamasında performans ve güvenlik gibi kritik unsurlar sistemin temel yapısına dahil edilir.",
        },
        {
          question:
            "Hangi test seviyesi, genellikle geliştirme sürecinin erken aşamalarında, yazılım modüllerinin bireysel olarak doğruluğunu kontrol etmek için kullanılır?",
          options: [
            "Sistem Testi",
            "Entegrasyon Testi",
            "Birim Testi",
            "Kabul Testi",
            "Kullanılabilirlik Testi",
          ],
          correct: 2,
          explanation:
            "Birim testi, modüllerin bireysel doğruluğunu erken aşamada kontrol eder.",
        },
        {
          question: "Hangisi çağlayan modelinin avantajlarından değildir?",
          options: [
            "Erken işin miktarını arttırır.",
            "Proje yöneticileri için işin dağılımını yapma açısından kolaydır.",
            "Aşamaları iyi anlaşılabilir.",
            "Gereksinimleri iyi anlaşılabilen projelerde iyi çalışır.",
            "Genelde yazılımın kullanıcıya ulaşma zamanı uzundur.",
          ],
          correct: 4,
          explanation:
            "Yazılımın kullanıcıya geç ulaşması, çağlayan modelinin bir dezavantajıdır, avantajı değildir.",
        },
        {
          question:
            "XP (Extreme Programming) yönteminde Pair Programming uygulamasının amacı nedir?",
          options: [
            "Kod yazma hızını artırmak",
            "Hataları en aza indirmek",
            "Müşteri memnuniyetini artırmak",
            "Sürekli entegrasyonu teşvik etmek",
            "Gereksinimleri daha अच्छी तरह समझना",
          ],
          correct: 1,
          explanation:
            "Pair Programming, iki geliştiricinin birlikte çalışarak hata oranını azaltmasını amaçlar.",
        },
        {
          question:
            "Bir çevik projede, ürün sahibi sürekli olarak sprint planı üzerinde değişiklikler yapmaktadır. Bu durum, ekip üzerinde hangi etkiye sahiptir?",
          options: [
            "Ekibin motivasyonunu ve üretkenliğini artırır.",
            "Ekibin moralini ve iş birliğini bozar.",
            "Ekibin planlama ve tahmin yeteneğini geliştirir.",
            "Ekibin çevik değerlerine olan bağlılığını güçlendirir.",
            "Ekibin ürünün kalitesine olan odaklanmasını sağlar.",
          ],
          correct: 1,
          explanation:
            "Sürekli değişiklikler, ekibin planlama yapmasını zorlaştırarak moral ve iş birliğini olumsuz etkiler.",
        },
        {
          question: "Hangisi yazılım geliştirme süreçlerinden biri değildir?",
          options: [
            "Waterfall Model",
            "Extreme Programming",
            "V-shaped Model",
            "Database Model",
            "Spiral Model",
          ],
          correct: 3,
          explanation:
            "Database Model, bir yazılım geliştirme süreci değil, veri yönetimi ile ilgilidir.",
        },
        {
          question:
            "“Bir modüldeki işlemler arasında denetim ilişkisi bulunmaktadır. İşlemlerin birbirleri ile veri ilişkisi yoktur, ancak işlem sırası önemlidir.” Bu modülde hangi yapışıklık türü kullanılmıştır?",
          options: [
            "İşlevsel yapışıklık",
            "Zamansal yapışıklık",
            "Yordamsal yapışıklık",
            "Sırasal yapışıklık",
            "Mantıksal yapışıklık",
          ],
          correct: 2,
          explanation:
            "Yordamsal yapışıklık, işlemlerin sırasının önemli olduğu ancak veri paylaşımının olmadığı durumlarda kullanılır.",
        },
        {
          question:
            "Çevik süreçlerin değişimi hoş karşılamasının nedeni nedir?",
          options: [
            "Geliştiricilerin iş yükünü azaltmak",
            "Müşterinin rekabetçi avantajını artırmak",
            "Projeyi daha hızlı tamamlamak",
            "Geliştiricilerin daha yaratıcı olmasını sağlamak",
            "Maliyetleri düşürmek",
          ],
          correct: 1,
          explanation:
            "Çevik süreçler, değişimi hoş karşılar çünkü bu, müşterinin piyasada avantaj elde etmesini sağlar.",
        },
        {
          question:
            "Aşağıdakilerden hangisi süreç akışı için kullanılan belirtim yöntemlerinden birisidir?",
          options: [
            "Düz Metin",
            "Karar Tabloları",
            "Karar Ağaçları",
            "Nesne-Sınıf Şemaları",
            "Algoritma",
          ],
          correct: 3,
          explanation:
            "Nesne-Sınıf Şemaları, süreç akışını değil, sistemin yapısını tanımlamak için kullanılır; diğerleri süreç akışı belirtim yöntemleridir.",
        },
        {
          question:
            "Aşağıdakilerden hangisi yazılım süreci modellerinden olan barok modeli özellikleri arasında sayılmaz?",
          options: [
            "Yaşam döngüsü temel adımlarının doğrusal bir şekilde geliştirildiği modeldir.",
            "Belgelemeyi işin doğal bir ürünü olarak görmektedir.",
            "Gerçekleştirim aşamasına daha fazla önem verilmiş bir modeldir.",
            "Aşamalar arası geri dönüşlerin nasıl yapılacağı belli değildir.",
            "Çağlayan modele göre geri dönüşler kötü tanımlanmıştır.",
          ],
          correct: 1,
          explanation:
            "Barok model, belgelemeyi doğal bir ürün olarak görmez; bu, daha çok çevik yaklaşımlara özgü bir özelliktir.",
        },
        {
          question: "Hangisi üç programlama özelliği değildir?",
          options: [
            "Takımın bilgisayarları kübiklerle bölünmüş büyük bir odanın ortasında yer alır.",
            "Hiç kimse aynı iş için peşpeşe iki haftadan fazla çalışamaz.",
            "Küçük ve orta ölçekli projelerde kullanılırlar",
            "Parçalar geliştirilmeden önce ayrı büyük bir tasarım aşaması yoktur.",
            "Takım içerisinde özelleşme vardır.",
          ],
          correct: 4,
          explanation:
            "Takım içerisinde özelleşme, çevik yaklaşımlarda değil, daha geleneksel modellerde görülür.",
        },
        {
          question: "Aşağıdakilerden hangisi donanımın bir özelliği değildir?",
          options: [
            "Yeni gereksinimler donanıma ekler yaparak yansıtılır.",
            "Ömrünü tamamladığında değiştirilebilirdir.",
            "Hayati önem taşıdığı için kopyasını barındırır.",
            "Donanım üretilir.",
            "Donanım bileşenleri dışarıdan temin edilebilir.",
          ],
          correct: 0,
          explanation:
            "Yeni gereksinimler donanıma eklerle yansıtılmaz; bu, yazılımın bir özelliğidir.",
        },
        {
          question:
            "Veri tasarımında dikkat edilmesi gereken unsurlardan hangisi yanlıştır?",
          options: [
            "Değişik veri yapıları değerlendirilmelidir.",
            "Veri yapıları üzerinde yapılacak işlemler tanımlanmalıdır.",
            "Alt düzeyde tasarım kararları tasarım süreci içerisinde geciktirilmelidir.",
            "Bazı çok kullanılan veri yapıları için bir kütüphane oluşturulmalıdır.",
            "Kullanılacak programlama dili somut veri tiplerini desteklemeli",
          ],
          correct: 4,
          explanation:
            "Programlama dilinin somut veri tiplerini desteklemesi bir gereklilik değildir; soyut veri tiplerini de kullanılabilir.",
        },
        {
          question:
            "Yazılım Geliştirme Yaşam Döngüsü (SDLC) hangi adımı içermez?",
          options: ["Planlama", "Analiz", "Muhasebe", "Gerçekleştirim"],
          correct: 2,
          explanation:
            "Muhasebe, SDLC’nin bir adımı değildir; diğerleri standart aşamalardır.",
        },
        {
          question: "Yazılım Süreci, aşağıdakilerden hangisini ifade eder?",
          options: [
            "Yazılımın kurulumu",
            "Yazılım geliştirme için birbiriyle tutarlı aktivite grubu",
            "Bilgisayar donanımının güncellenmesi",
            "İnternet bağlantısının kurulması",
          ],
          correct: 1,
          explanation:
            "Yazılım süreci, geliştirme için tutarlı aktiviteleri kapsar.",
        },
        {
          question: "Hangi modelin başarısı ilk evrimin başarısına bağımlıdır?",
          options: [
            "Helezonoik model",
            "V model",
            "Çağlayan model",
            "Barok model",
            "Evrimsel geliştirme modeli",
          ],
          correct: 4,
          explanation:
            "Evrimsel geliştirme modeli, ilk evrimin başarısına bağlı olarak ilerler.",
        },
        {
          question:
            "Aşağıdakilerden hangisi yordamsal tasarım ile mimari tasarım arasındaki farklardan biridir?",
          options: [
            "Yordamsal tasarım, diğer modüllere hizmet sağlayan sistem bileşenlerini tanımlar; mimari tasarım ise yazılım modüllerinin iç yapısını tanımlar.",
            "Mimari tasarım, algoritmik ayrıntıları belirler; yordamsal tasarım ise sistem bileşenlerinin genel yapısını tanımlar.",
            "Mimari tasarım, bağımsız bir sistem olarak çalışabilir; yordamsal tasarım ise diğer modüllerin sağladığı hizmetleri kullanır.",
            "Yordamsal tasarım, yazılım modüllerinin iç yapısındaki algoritmik ayrıntıları tanımlar; mimari tasarım ise sistem bileşenlerini ve onların ilişkilerini tanımlar.",
            "Yordamsal tasarım, nesne, program, paket gibi bileşenler içerir; mimari tasarım ise prosedür ve fonksiyonları içerir.",
          ],
          correct: 3,
          explanation:
            "Yordamsal tasarım, algoritmik detayları içerir; mimari tasarım ise sistemin genel yapısını ve ilişkilerini tanımlar.",
        },
        {
          question:
            "Kara kutu testi hakkında aşağıdakilerden hangisi yanlıştır?",
          options: [
            "Kara kutu testi yazılımın arayüzü düzeyinde yapılır.",
            "Amaç yazılımın işlevlerini yerine getirdiğini göstermektir.",
            "Kullanıcı, bu testler sırasında yazılımın içyapısıyla ilgilenir.",
            "Girdi ya da çıktılar çeşitli ortamlarda sağlanan veri ya da bilgi olabileceği gibi bir donanımdan veri alınması veya bir donanıma kumanda edilmesi de olabilir.",
            "Testlerin düzeyi, kullanım alanına göre değişiklik gösterebilir.",
          ],
          correct: 2,
          explanation:
            "Kara kutu testinde kullanıcı, yazılımın iç yapısıyla ilgilenmez; yalnızca giriş ve çıkışlara odaklanır.",
        },
        {
          question:
            "Aşağıdakilerden hangisinde yazılım test türleri ve test stratejileri hakkında verilen bilgilerden hangisi doğrudur?",
          options: [
            "Saydam kutu testi, kullanıcı arayüzüne odaklanır ve iç işleyişi dikkate almaz.",
            "Birim testinde (Unit Test), çok programlı sistemlerde birimlerin ayrı ayrı test edilmesine gerek yoktur.",
            "Kara Kutu testinde, sistem gereksinimlerine dayanarak esas kullanıcıya yönelik test durumları oluşturur.",
            "Alfa testinde, geliştirici genellikle bu testlere katılmaz yalnızca belirli aralıklara sonuçları ve yorumları alır.",
            "Sistem testi, yazılımın diğer donanım ve yazılımlarla nasıl etkileştiğini test eder ve bu testlerden sonra hata bulma ve sistemi deneme amacıyla hazırlık testleri yapılır.",
          ],
          correct: 2,
          explanation:
            "Kara kutu testi, sistem gereksinimlerine dayanarak kullanıcı odaklı testler oluşturur.",
        },
        {
          question: "Çevik Manifesto'ya göre en önemli öncelik nedir?",
          options: [
            "Projeyi hızlıca tamamlamak",
            "Geliştiricilerin memnuniyeti",
            "Müşteriyi değerli yazılımı erken zamanda ve sürekli sunarak memnun etmek",
            "Gereksinimlerin değişmemesi",
            "Geliştirme sürecinde maliyeti düşürmek",
          ],
          correct: 2,
          explanation:
            "Çevik Manifesto’nun temel önceliği, müşteriye erken ve sürekli değer sunmaktır.",
        },
        {
          question: "Spiral modelinin temel amacı nedir?",
          options: [
            "Tekrarlayan geliştirme ile riskleri azaltmak.",
            "Projeyi hızlı bir şekilde tamamlamak.",
            "Müşteri geri bildirimlerine dayalı geliştirme.",
            "Ayrıntılı dokümantasyon oluşturmak.",
            "Proje maliyetlerini minimize etmek.",
          ],
          correct: 0,
          explanation:
            "Spiral model, riskleri azaltmak için tekrarlayan bir yaklaşım benimser.",
        },
        {
          question:
            "Extreme Programming yönteminde çiftler halinde çalışan yazılımcılar hangi faaliyeti birlikte gerçekleştirir?",
          options: [
            "Kodlama ve test etme",
            "Gereksinim analizi",
            "Proje planlaması",
            "Müşteri değerlendirmesi",
            "Yazılım dağıtımı",
          ],
          correct: 0,
          explanation:
            "Çift programlama, kodlama ve test etmeyi birlikte yapmayı içerir.",
        },
        {
          question:
            "Agile süreçlerinde, müşteri memnuniyetini sağlamak için hangi ilke benimsenir?",
          options: [
            "Projenin başında tüm gereksinimlerin sabitlenmesi",
            "Değişen gereksinimlerin kabul edilmesi",
            "Uzun süreli planlamalar yapılması",
            "Müşteri geri bildirimlerinin göz ardı edilmesi",
            "Yalnızca iç süreçlere odaklanılması",
          ],
          correct: 1,
          explanation:
            "Çevik süreçler, değişen gereksinimleri kabul ederek müşteri memnuniyetini hedefler.",
        },
        {
          question:
            "Aşağıdakilerden hangisi Extreme Programming (XP) pratiği değildir?",
          options: [
            "Pair Programming",
            "Continuous Integration",
            "Waterfall Planning",
            "Refactoring",
            "Testing",
          ],
          correct: 2,
          explanation:
            "Waterfall Planning, XP’nin bir pratiği değildir; XP iteratif bir yaklaşımdır.",
        },
        {
          question:
            "Aşağıdaki bakım türlerinden hangisi, yazılımın performansını artırmak, bellek sızıntılarını gidermek ve kod tabanını temizlemek için yapılan bakım türü olarak sınıflandırılabilir?",
          options: [
            "Uyarlayıcı Bakım",
            "Düzeltici Bakım",
            "İyileştirici Bakım",
            "Önleyici Bakım",
            "Kapsamlı Bakım",
          ],
          correct: 3,
          explanation:
            "Önleyici bakım, performans artışı ve kod temizliği gibi proaktif iyileştirmeleri kapsar.",
        },
        {
          question:
            "Bir yazılım projesinde sistem testi aşaması sırasında, aşağıdaki faaliyetlerden hangisi gerçekleştirilmez?",
          options: [
            "Yazılımın tüm fonksiyonlarının doğru çalıştığı doğrulanır.",
            "Yazılımın performansı ölçülür ve gereksinimlere uygun olup olmadığı belirlenir.",
            "Yazılımın kullanıcı arayüzü, kullanılabilirlik ve erişilebilirlik açısından değerlendirilir.",
            "Yazılım kodunun derlenmesi ve hata ayıklama işlemi yapılır.",
            "Tüm sistem testi senaryolarının başarılı bir şekilde tamamlanmasının ardından, yazılımın kullanıcılar tarafından kabul edilip edilmeyeceği belirlenir",
          ],
          correct: 3,
          explanation:
            "Kod derleme ve hata ayıklama, sistem testi değil, geliştirme aşamasında yapılır.",
        },
        {
          question:
            "Yazılım teslim edildikten sonra, kullanıcı, kullanım sırasında karşılaştığı yanlış hesaplama, hatalı davranış, eksik veri gösterimi gibi yazılım kusurlarını bildirerek düzeltilmesini isteyebilir. Bu yazılım bakım türü aşağıdaki hangi bakım türü için en doğru olur?",
          options: [
            "Düzeltici (Corrective) bakım",
            "Uyarlayıcı (Adaptive) bakım",
            "İyileştirici (Perfective) bakım",
            "Önleyici (Preventive) bakım",
            "Geliştirici (Developer) bakım",
          ],
          correct: 0,
          explanation:
            "Düzeltici bakım, mevcut hataları düzeltmek için yapılır.",
        },
        {
          question:
            "Aşağıdakilerden hangisi yazılım süreç modeli olan helezonik modelin avantajlarından biri değildir?",
          options: [
            "Pek çok yazılım modelini içinde bulundurur.",
            "Geliştirmeyi küçük parçalara böler. En riskli kısımlar önce gerçekleştirilir.",
            "Her döngü bir fazı ifade eder. Doğrudan tanımlama, tasarım,... vs gibi bir faz yoktur.",
            "Küçük ve düşük riskli projeler için ucuz bir yöntemdir.",
            "Geliştirmeyi küçük parçalara böler. En riskli kısımlar önce gerçekleştirilir.",
          ],
          correct: 3,
          explanation:
            "Helezonik model, karmaşık ve riskli projeler için uygundur; küçük ve düşük riskli projelerde genellikle maliyet etkin değildir.",
        },
        {
          question:
            "Hangi özellik, Çağlayan Modeli ile Agile Modeller arasındaki farkı en iyi açıklar?",
          options: [
            "Çağlayan Modeli, yazılım geliştirme sürecini tek bir büyük döngüde yönetirken, Agile Modeller birden fazla küçük döngüde çalışır.",
            "Çağlayan Modeli, bireysel geliştiricilerin inisiyatifini teşvik ederken, Agile Modeller daha fazla mikro yönetim sağlar.",
            "Çağlayan Modeli, değişen müşteri gereksinimlerine hızla uyum sağlayabilirken, Agile Modeller daha fazla belgelendirme ve iş süreci standardizasyonu sağlar.",
            "Çağlayan Modeli, yazılım geliştirme sürecini sıkı bir plan ve sıralı adımlarla yönetirken, Agile Modeller daha esnek ve iteratif bir yaklaşım benimser.",
          ],
          correct: 3,
          explanation:
            "Çağlayan modeli sıralı ve katıdır; Agile ise esnek ve iteratiftir.",
        },
        {
          question:
            "Bir hastane için hastaların hayati belirtilerini izleyen bir tıbbi cihaz yazılımı geliştirilmek isteniyor. Bu yazılım için aşağıdaki yazılım süreç modellerinden hangisi uygundur?",
          options: [
            "Gelişigüzel model",
            "Barok Modeli",
            "Çağlayan (Şelale) Modeli",
            "V Süreç Modeli",
            "Artırımlı Geliştirme Süreç Modeli",
          ],
          correct: 3,
          explanation:
            "V Süreç Modeli, kritik sistemlerde doğrulama ve validasyona odaklandığı için uygundur.",
        },
        {
          question:
            "Aşağıdakilerden hangisi çevik (agile) proje geliştirme metodolojisinin dezavantajlarından biri değildir?",
          options: [
            "Ürün gereksinimleri sürekli değişebileceğinden maliyetler önceden tahmin edilemez.",
            "Ekip katılımına öncelik verilerek kurulan iletişim sayesinde sorunların daha hızlı çözülmesini sağlar.",
            "Gerekli olan her aşamada müşteriden geri bildirim almak zor olabilir.",
            "Müşteriler geri bildirim vermek istediklerinde akıllarına gelebilecek yeni istekler ek işleri ortaya çıkarır.",
            "Müşteri ile iletişimi zor olan büyük kurumsal yapılarda uygulamak zordur.",
          ],
          correct: 1,
          explanation:
            "Ekip katılımı ve iletişim, çevik metodolojinin bir avantajıdır, dezavantajı değildir.",
        },
        {
          question:
            "Aşağıdakilerden hangisi extreme programmingde pair working etkinliğini arttırır?",
          options: [
            "Ekip üyelerinin sürekli farklı partnerlerle çalışmasını sağlamak.",
            "Bir partnerin diğerine göre daha çok çalışması.",
            "Partnerlerin birbirleriyle çok sık çatışması.",
            "Bir partnerin diğerine göre daha çok karar alması.",
            "Birbirleriyle anlaşamayan ekip üyelerini eşleştirmek.",
          ],
          correct: 0,
          explanation:
            "Farklı partnerlerle çalışma, bilgi paylaşımını ve etkinliği artırır.",
        },
        {
          question:
            "Aşağıdakilerden hangisi Helezonik Model'in Avantajlarından biri değildir?",
          options: [
            "Risk analizi olgusu ön plandadır.",
            "Prototip yaklaşımı vardır.",
            "Ara adımların fazlalığı nedeniyle dokümantasyon gerektirir.",
            "Kullanıcılar sistemi erken görebilir.",
            "Hataları erken gidermeye odaklanır.",
          ],
          correct: 2,
          explanation:
            "Dokümantasyon gerekliliği, Helezonik Model’in bir dezavantajıdır, avantajı değildir.",
        },
        {
          question: "Aşağıdakilerden hangisi bakım türlerinden değildir?",
          options: [
            "Düzeltici (Corrective)",
            "Uyarlayıcı (InlineAdaptive)",
            "Geliştirici (Enhancive)",
            "İyileştirici (Perfective)",
            "Önleyici (Preventive)",
          ],
          correct: 2,
          explanation:
            "Geliştirici (Enhancive), standart bir bakım türü değildir.",
        },
        {
          question:
            "Aşağıdakilerden hangisi Helezonik Model'in Avantajlarından biri değildir?",
          options: [
            "Risk analizi olgusu ön plandadır.",
            "Prototip yaklaşımı vardır.",
            "Ara adımların fazlalığı nedeniyle dokümantasyon gerektirir.",
            "Kullanıcılar sistemi erken görebilir.",
            "Hataları erken gidermeye odaklanır.",
          ],
          correct: 2,
          explanation:
            "Dokümantasyon gerekliliği, Helezonik Model’in bir dezavantajıdır, avantajı değildir.",
        },
        {
          question: "Aşağıdakilerden hangisi bir yazılım bakım türü değildir?",
          options: [
            "Düzeltici",
            "Uyarlayıcı",
            "Denetleyici",
            "Önleyici",
            "İyileştirici",
          ],
          correct: 2,
          explanation:
            "Denetleyici, bir bakım türü değildir; diğerleri standart bakım türleridir.",
        },
        {
          question:
            "Aşağıdaki projelerden hangisinin Çağlayan (Waterfall) modeli ile yapılması daha olasıdır?",
          options: [
            "Mobil uygulama tasarımı",
            "Yapay zeka algoritma yazılımı tasarımı",
            "Bir e-ticaret web sitesi tasarımı",
            "Bir startup ın yeni bir ürün fikrini test etmek için geliştirdiği prototip tasarımı",
            "MR cihazı için yazılım tasarımı",
          ],
          correct: 4,
          explanation:
            "MR cihazı gibi kritik ve iyi tanımlı gereksinimlere sahip projeler, Çağlayan modeli için uygundur.",
        },
        {
          question:
            "Bir yazılımın 'major' numarasının artırılmasının genellikle hangi durumu temsil ettiği aşağıdakilerden hangisidir?",
          options: [
            "Yeni bir özellik eklenmesi",
            "Bir hata giderilmesi",
            "Köklü değişiklikler ve yeni bir ortama uyarlamalar",
            "Yazılımın general availability (GA) aşamasına geçmesi",
            "Oluşturulan bir prototipin test edilmesi",
          ],
          correct: 2,
          explanation:
            "Major numara, köklü değişiklikleri ve büyük güncellemeleri temsil eder.",
        },
        {
          question:
            "Aşağıdaki ifadelerden hangisi Extreme Programming (XP) metodolojisinin temel ilkeleri ve uygulamaları ile doğru bir şekilde eşleştirilmiştir?",
          options: [
            "Incremental Development - Tüm sistemin tek seferde geliştirilmesi ve ardından test edilmesi",
            "Test-Driven Development (TDD) - Kod yazımı tamamlandıktan sonra testlerin yazılması ve yürütülmesi",
            "Continuous Integration - Kodun belirli aralıklarla entegre edilip büyük sürümlerin yayımlanması",
            "Refactoring - Kodun işlevselliğini değiştirmeden yapısal olarak iyileştirilmesi",
            "Pair Programming - Geliştiricilerin bireysel olarak çalışıp daha sonra kodlarını birleştirmesi",
          ],
          correct: 3,
          explanation:
            "Refactoring, XP’de kodun yapısını iyileştirmeyi ifade eder ve doğru eşleşmedir.",
        },
        {
          question:
            "Aşağıdakilerden hangisi yazılımın temel krizleri arasında gösterilemez?",
          options: [
            "Tasarlanan zamanın gerisinde kalma",
            "Bütçeyi aşma",
            "Güvenilir olmayan yazılım",
            "Bu sektörle ilgilenen kişi sayısının çok olması",
            "Sürekliliğin sağlanmasındaki zorluk",
          ],
          correct: 3,
          explanation:
            "Sektördeki kişi sayısı, yazılım krizlerinden biri değildir; diğerleri yaygın krizlerdir.",
        },
        {
          question:
            "Aşağıda verilen Kara kutu testi ile ilgili maddelerden hangisi yanlıştır?",
          options: [
            "Yazılımın ara yüzü düzeyinde yapılır.",
            "Kullanıcı, bu testler sırasında yazılımın iç yapısıyla ilgilenir.",
            "Amaç yazılımın işlevlerini yerine getirdiğini göstermektir.",
            "Testler hata bulmak için yapılır.",
            "Testlerin düzey, kullanım alanına göre değişiklik gösterebilir.",
          ],
          correct: 1,
          explanation:
            "Kara kutu testinde kullanıcı, iç yapıyla ilgilenmez; sadece giriş-çıkışlar test edilir.",
        },
        {
          question:
            "Aşağıdakilerden hangisi metodolojilerde helezonik modeli ön plana çıkaran özelliklerden sayılmaz?",
          options: [
            "Prototip yaklaşımı",
            "Risk analizi",
            "Evrimsel yaklaşım",
            "Her döngünün bir faza karşılık geldiği yaklaşım",
            "Yinelemeli artırımsal yaklaşım",
          ],
          correct: 2,
          explanation:
            "Evrimsel yaklaşım, helezonik modelin değil, evrimsel geliştirme modelinin özelliğidir.",
        },
      ];
      let currentModel = questionsModel7; // Default to model7
      let currentQuestion = 0;
      let score = 0;
      let answered = Array(currentModel.length).fill(false);
      let userAnswers = Array(currentModel.length).fill(null);
      let wrongQuestions = [];
      let isRetrying = false;

      const questionArea = document.getElementById("questionArea");
      const explanationDiv = document.getElementById("explanation");
      const scoreDiv = document.getElementById("score");
      const tableBody = document.getElementById("tableBody");
      const modelSelect = document.getElementById("modelSelect");
      const submitBtn = document.getElementById("submitBtn");
      const overlay = document.getElementById("overlay");
      const popup = document.getElementById("popup");
      const popupScore = document.getElementById("popupScore");
      const retryWrongBtn = document.getElementById("retryWrongBtn");
      const closePopupBtn = document.getElementById("closePopupBtn");

      function displayQuestion() {
        const q = currentModel[currentQuestion];
        questionArea.innerHTML = `
              <p class="text-lg text-gray-800">${currentQuestion + 1}. ${
          q.question
        }</p>
              <ul class="space-y-2 mt-2">
                ${q.options
                  .map(
                    (opt, i) => `
                  <li><label class="flex items-center"><input type="radio" name="answer" value="${i}" ${
                      answered[currentQuestion] ? "disabled" : ""
                    } class="mr-2"> ${opt}</label></li>
                `
                  )
                  .join("")}
              </ul>
            `;
        explanationDiv.classList.add("hidden");
        submitBtn.textContent = answered[currentQuestion]
          ? "Next"
          : "Submit Answer";
        if (
          answered[currentQuestion] &&
          userAnswers[currentQuestion] !== null
        ) {
          showExplanation();
        }
      }

      function updateScore() {
        scoreDiv.textContent = `Score: ${score}/${currentModel.length}`;
      }

      function updateTable() {
        tableBody.innerHTML = currentModel
          .map((_, i) => {
            const status = answered[i]
              ? userAnswers[i] === currentModel[i].correct
                ? "Correct"
                : "Incorrect"
              : "Not Answered";
            const className = answered[i]
              ? userAnswers[i] === currentModel[i].correct
                ? "correct"
                : "incorrect"
              : "";
            return `
                <tr class="${i % 2 === 0 ? "bg-gray-50" : "bg-white"}">
                  <td class="border p-2">${i + 1}</td>
                  <td class="border p-2 ${className}">${status}</td>
                </tr>`;
          })
          .join("");
      }

      function showExplanation() {
        const q = currentModel[currentQuestion];
        const userAnswer = userAnswers[currentQuestion];
        explanationDiv.classList.remove("hidden");
        if (userAnswer === q.correct) {
          explanationDiv.innerHTML = `<p class="correct">Correct! ${q.explanation}</p>`;
        } else {
          explanationDiv.innerHTML = `<p class="incorrect">Wrong! Correct answer: ${
            q.options[q.correct]
          }. ${q.explanation}</p>`;
        }
      }

      function submitAnswer() {
        if (answered[currentQuestion]) {
          goToNextQuestion();
          return;
        }
        const selected = document.querySelector('input[name="answer"]:checked');
        if (!selected) {
          alert("Please select an answer!");
          return;
        }
        const answer = parseInt(selected.value);
        userAnswers[currentQuestion] = answer;
        answered[currentQuestion] = true;
        if (answer === currentModel[currentQuestion].correct) {
          score++;
        } else {
          wrongQuestions.push(currentQuestion);
        }
        showExplanation();
        updateScore();
        updateTable();
        document
          .querySelectorAll('input[name="answer"]')
          .forEach((input) => (input.disabled = true));
        submitBtn.textContent = "Next";
      }

      function goToNextQuestion() {
        currentQuestion++;
        if (currentQuestion >= currentModel.length) {
          showScorePopup();
        } else {
          displayQuestion();
        }
      }

      function showScorePopup() {
        overlay.style.display = "block";
        popup.style.display = "block";
        popupScore.textContent = `Your score: ${score}/${currentModel.length}`;
        retryWrongBtn.style.display =
          wrongQuestions.length > 0 ? "inline-block" : "none";
      }

      function resetQuiz() {
        currentQuestion = 0;
        score = 0;
        answered.fill(false);
        userAnswers.fill(null);
        wrongQuestions = [];
        isRetrying = false;
        currentModel = currentModel; // Always use model7 for now
        displayQuestion();
        updateScore();
        updateTable();
        overlay.style.display = "none";
        popup.style.display = "none";
      }

      function randomizeQuestions() {
        for (let i = currentModel.length - 1; i > 0; i--) {
          const j = Math.floor(Math.random() * (i + 1));
          [currentModel[i], currentModel[j]] = [
            currentModel[j],
            currentModel[i],
          ];
        }
        resetQuiz();
      }

      function switchModel() {
        if (modelSelect.value === "model8") {
          currentModel = questionsModel8;
        }
        if (modelSelect.value === "model7") {
          currentModel = questionsModel7;
        }
        if (modelSelect.value === "pdf7&8") {
          currentModel = pdf7_8;
        }
        if (modelSelect.value === "pdf9") {
          currentModel = pdf9;
        }
        if (modelSelect.value === "pdf10") {
          currentModel = pdf10;
        }

        resetQuiz();
      }

      function retryWrongQuestions() {
        if (wrongQuestions.length === 0) return;
        const wrongIndices = [...wrongQuestions];
        currentModel = wrongIndices.map((i) => currentModel[i]);
        currentQuestion = 0;
        score = 0;
        answered = Array(currentModel.length).fill(false);
        userAnswers = Array(currentModel.length).fill(null);
        wrongQuestions = [];
        isRetrying = true;
        displayQuestion();
        updateScore();
        updateTable();
        overlay.style.display = "none";
        popup.style.display = "none";
      }

      submitBtn.addEventListener("click", submitAnswer);
      document.getElementById("resetBtn").addEventListener("click", resetQuiz);
      document
        .getElementById("randomBtn")
        .addEventListener("click", randomizeQuestions);
      modelSelect.addEventListener("change", switchModel);
      retryWrongBtn.addEventListener("click", retryWrongQuestions);
      closePopupBtn.addEventListener("click", () => {
        overlay.style.display = "none";
        popup.style.display = "none";
      });

      displayQuestion();
      updateScore();
      updateTable();
    </script>
  </body>
</html>
